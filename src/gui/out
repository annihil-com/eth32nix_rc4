// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CBallisticWindow::CBallisticWindow(const char *label, int wx, int wy, int ww, int wh)
: CWindow(label, wx, wy, ww, wh)
{
	showTitle = false;
	Resize(w, (GUI_FONTHEIGHT * 4) + (GUI_TEXTSPACING * 3) + 10);
}

void CBallisticWindow::Display(void)
{
	if (!(eth32.cg.currentWeapon->attribs & WA_BALLISTIC))
		return;

	static char buffer[64];
	int yPos = y + 5;

	CWindow::Display();

	sprintf(buffer, "%.2f", 0.001*(float)eth32.cg.snap->ps.grenadeTimeLeft);
	Draw.Text(x + 5, yPos, GUI_FONTSCALE, "Time Remaining:", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - 5 - TEXTWIDTH(buffer), yPos, GUI_FONTSCALE, buffer, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);	
	yPos += GUI_FONTHEIGHT + GUI_TEXTSPACING;

	if (Aimbot.grenadeTarget) 
		strncpy(buffer, Aimbot.grenadeTarget->name, Draw.BreakStringByWidth(Aimbot.grenadeTarget->name, w - 15 - TEXTWIDTH("Target:"), NULL, GUI_FONT, false));
	else
		strcpy(buffer, "<none>");

	Draw.Text(x + 5, yPos, GUI_FONTSCALE, "Target:", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - 5 - TEXTWIDTH(buffer), yPos, GUI_FONTSCALE, buffer, GUI_FONTCOLOR2, qfalse, qfalse, GUI_FONT, true);
	yPos += GUI_FONTHEIGHT + GUI_TEXTSPACING;

	sprintf(buffer, "%i", Aimbot.grenadeTarget ? (int)Aimbot.grenadeTarget->distance : -1);
	Draw.Text(x + 5, yPos, GUI_FONTSCALE, "Distance:", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - 5 - TEXTWIDTH(buffer), yPos, GUI_FONTSCALE, buffer, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	yPos += GUI_FONTHEIGHT + GUI_TEXTSPACING;

	sprintf(buffer, "%.1f s", Aimbot.grenadeTarget ? Aimbot.rifleGrenadeTime : 0.0);
	Draw.Text(x + 5, yPos, GUI_FONTSCALE, "Flytime:", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - 5 - TEXTWIDTH(buffer), yPos, GUI_FONTSCALE, buffer, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);	
}

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"

class CBallisticWindow : public CWindow
{
public:
	CBallisticWindow(const char *label, int wx, int wy, int ww, int wh);
	void Display(void);
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CButton::CButton(const char *clabel, int cx, int cy, int cw, int ch, void (*cfunc)(void))
: CControl(clabel, cx, cy, cw, ch)
{
	func = cfunc;
}

void CButton::Display(void)
{
	if (!show)
		return;

	if (selected) {
		Draw.RawPic(x, y, h, h, eth32.guiAssets.btnselLeft);
		Draw.RawPic(x + h, y, w-(h+h), h, eth32.guiAssets.btnselCenter);
		Draw.RawPic(x2 - h, y, h, h, eth32.guiAssets.btnselRight);
	}
	else {
		Draw.RawPic(x, y, h, h, eth32.guiAssets.btnLeft);
		Draw.RawPic(x + h, y, w-(h+h), h, eth32.guiAssets.btnCenter);
		Draw.RawPic(x2 - h, y, h, h, eth32.guiAssets.btnRight);
	}

	Draw.TextCenter(x + (w >> 1), y + ((h - GUI_FONTHEIGHT) >> 1), GUI_FONTSCALE, label, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
}

int CButton::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (!show)
		return 1;

	if (INBOUNDS(mx,my)) {
		if (mevent == WM_LBUTTONDOWN) {
			selected = true;
			*mhook = this;
		}
		else if (mevent == WM_LBUTTONUP && selected) {
			if (func)
				func();
			selected = false;
			*mhook = NULL;
		}
		else {
			selected = false;
			*mhook = NULL;
		}
		return 0;
	}
	return 1;
}

void CButton::MouseMove(int mx, int my)
{
	selected = INBOUNDS(mx,my);
}
	

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CControl.h"

class CButton : public CControl
{
public:
	CButton(const char *clabel, int cx, int cy, int cw, int ch, void (*cfunc)(void));
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 event, CControl **mhook, CControl **khook);
	void MouseMove(int mx, int my);
private:
	void (*func)(void);
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CCameraWindow::CCameraWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	cameraActive = false;
	type = -1;
}

void CCameraWindow::Display(void)
{
	if (!eth32.cg.snap || !Engine.forward || !eth32.cg.snap->ps.weapon || eth32.cg.snap->ps.weapon > eth32.cg.numWeapons) {
		cameraActive = false;
		type = -1;
		return;
	}

	int weapnum = eth32.cg.snap->ps.weapon;
	
	if(eth32.settings.cams[CAM_FOLLOW].display && !VectorCompare(Cam.gentityOrigin, vec3_origin) ) {
		type = CAM_FOLLOW;
		Cam.followCam(&eth32.settings.cams[CAM_FOLLOW]);
	} else if (IS_WEAPATTRIB(weapnum, WA_MORTAR) && eth32.settings.cams[CAM_MORTAR].display) {
		type = CAM_MORTAR;
		Cam.mortarCam(&eth32.settings.cams[CAM_MORTAR]);
	} else if(eth32.settings.cams[CAM_TARGET].display && Cam.targetClientNum != -1) {
		type = CAM_TARGET;
		Cam.targetCam(&eth32.settings.cams[CAM_TARGET]);
	} else if (IS_WEAPATTRIB(weapnum, WA_RIFLE_GRENADE) && eth32.settings.cams[CAM_RIFLE].display) {
		type = CAM_RIFLE;
		Cam.rifleCam(&eth32.settings.cams[CAM_RIFLE]);
	} else if (IS_WEAPATTRIB(weapnum, WA_PANZER) && eth32.settings.cams[CAM_PANZER].display) {
		type = CAM_PANZER;
		Cam.panzerCam(&eth32.settings.cams[CAM_PANZER]);
	} else if (eth32.settings.cams[CAM_ENEMY].display) {
		type = CAM_ENEMY;
		Cam.enemyCam(&eth32.settings.cams[CAM_ENEMY]);
	} else if (IS_WEAPATTRIB(weapnum, WA_SATCHEL) && eth32.settings.cams[CAM_SATCHEL].display) {
		type = CAM_SATCHEL;
		Cam.satchelCam(&eth32.settings.cams[CAM_SATCHEL]);
	} /*else if (!IS_WEAPATTRIB(weapnum, WT_EXPLOSIVE) && eth32.settings.cams[CAM_GRENADE].display) {
		type = CAM_GRENADE;
		Cam.grenadeCam(&eth32.settings.cams[CAM_GRENADE]); // shows for knife etc..
	} */else if(eth32.settings.cams[CAM_MIRROR].display) {
		type = CAM_MIRROR;
		Cam.mirrorCam(&eth32.settings.cams[CAM_MIRROR]);
	} else if(CAM_DROP_ONE == Cam.closestCam && eth32.settings.cams[CAM_DROP_ONE].active) {
		type = CAM_DROP_ONE;
		Cam.dropCam(&eth32.settings.cams[CAM_DROP_ONE]);
	} else if(CAM_DROP_TWO == Cam.closestCam && eth32.settings.cams[CAM_DROP_TWO].active) {
		type = CAM_DROP_TWO;
		Cam.dropCam(&eth32.settings.cams[CAM_DROP_TWO]);
	} else if(CAM_DROP_THREE == Cam.closestCam && eth32.settings.cams[CAM_DROP_THREE].active) {
		type = CAM_DROP_THREE;
		Cam.dropCam(&eth32.settings.cams[CAM_DROP_THREE]);
	} else if(CAM_DROP_FOUR == Cam.closestCam && eth32.settings.cams[CAM_DROP_FOUR].active) {
		type = CAM_DROP_FOUR;
		Cam.dropCam(&eth32.settings.cams[CAM_DROP_FOUR]);
	} else { // not a camera type weapon
		cameraActive = false;
		type = -1;
		return;
	}

	cameraActive = true;
	
	if (Gui.InputActive()) {
		camInfo_t *cinfo = &eth32.settings.cams[type];
		// draw corners
		Draw.RawPicST(cinfo->x1 - 4, cinfo->y1 - 4, 16, 16, 0, 0, 1, 1, eth32.guiAssets.camCorner);
		Draw.RawPicST(cinfo->x2 - 12, cinfo->y1 - 4, 16, 16, 1, 0, 0, 1, eth32.guiAssets.camCorner);
		Draw.RawPicST(cinfo->x1 - 4, cinfo->y2 - 12, 16, 16, 0, 1, 1, 0, eth32.guiAssets.camCorner);
		Draw.RawPicST(cinfo->x2 - 12, cinfo->y2 - 12, 16, 16, 1, 1, 0, 0, eth32.guiAssets.camCorner);
	}
}

int CCameraWindow::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (!cameraActive) {
		if (*mhook == this) {
			*mhook = NULL;
			return 0;	// we had focus, but no longer camera... release mouse focus
		}
		return 1; // no camera active, let GUI search for a valid window
	}

	camInfo_t *cinfo = &eth32.settings.cams[type];

	if (INBOUNDS2(mx, my, cinfo->x1 - 4, cinfo->y1 - 4, cinfo->x2 + 4, cinfo->y2 + 4)) {
		if (mevent == WM_LBUTTONDOWN) {
			if (INBOUNDS3(mx, my, cinfo->x1 + 4, cinfo->y1 + 4, 8, 8))
				cornerActive = CORNER_TL;
			else if (INBOUNDS3(mx, my, cinfo->x2 - 4, cinfo->y1 + 4, 8, 8))
				cornerActive = CORNER_TR;
			else if (INBOUNDS3(mx, my, cinfo->x1 + 4, cinfo->y2 - 4, 8, 8))
				cornerActive = CORNER_BL;
			else if (INBOUNDS3(mx, my, cinfo->x2 - 4, cinfo->y2 - 4, 8, 8))
				cornerActive = CORNER_BR;
			else
				cornerActive = -1; // move whole window

			prevx = mx;
			prevy = my;
			*mhook = this;
		}
		return 0;
	}
	return 1;
}

int CCameraWindow::MouseWheel(int mx, int my, int wheel)
{
	if (!cameraActive)
		return 1;

	camInfo_t *cinfo = &eth32.settings.cams[type];

	if (INBOUNDS2(mx,my,cinfo->x1,cinfo->y1,cinfo->x2,cinfo->y2)) {
		cinfo->distance += -wheel * 100.f;
		
		if (cinfo->distance > 2000.f) 
			cinfo->distance = 2000.f;
		if (cinfo->distance < 0.f)
			cinfo->distance = 0.f;

		return 0;
	}
	return 1;
}
		
void CCameraWindow::MouseMove(int mx, int my)
{
	if (!cameraActive)
		return;

	camInfo_t *cinfo = &eth32.settings.cams[type];

	int deltax = mx - prevx;
	int deltay = my - prevy;

	prevx = mx;
	prevy = my;

	switch (cornerActive)
	{
	case CORNER_TL:
		cinfo->x1 += deltax;
		cinfo->y1 += deltay;
		
		if (cinfo->x1 < 4)
			cinfo->x1 = 4;
		else if ((cinfo->x2 - cinfo->x1) < CAM_MIN_SIZE)
			cinfo->x1 = cinfo->x2 - CAM_MIN_SIZE;

		if (cinfo->y1 < 4)
			cinfo->y1 = 4;
		else if ((cinfo->y2 - cinfo->y1) < CAM_MIN_SIZE)
			cinfo->y1 = cinfo->y2 - CAM_MIN_SIZE;
		break;
	case CORNER_TR:
		cinfo->x2 += deltax;
		cinfo->y1 += deltay;
		
		if (cinfo->x2 > (eth32.game.glconfig->vidWidth - 4))
			cinfo->x2 = eth32.game.glconfig->vidWidth - 4;
		else if ((cinfo->x2 - cinfo->x1) < CAM_MIN_SIZE)
			cinfo->x2 = cinfo->x1 + CAM_MIN_SIZE;

		if (cinfo->y1 < 4)
			cinfo->y1 = 4;
		else if ((cinfo->y2 - cinfo->y1) < CAM_MIN_SIZE)
			cinfo->y1 = cinfo->y2 - CAM_MIN_SIZE;
		break;
	case CORNER_BL:
		cinfo->x1 += deltax;
		cinfo->y2 += deltay;
		
		if (cinfo->x1 < 4)
			cinfo->x1 = 4;
		else if ((cinfo->x2 - cinfo->x1) < CAM_MIN_SIZE)
			cinfo->x1 = cinfo->x2 - CAM_MIN_SIZE;

		if (cinfo->y2 > (eth32.game.glconfig->vidHeight - 4))
			cinfo->y2 = eth32.game.glconfig->vidHeight - 4;
		else if ((cinfo->y2 - cinfo->y1) < CAM_MIN_SIZE)
			cinfo->y2 = cinfo->y1 + CAM_MIN_SIZE;
		break;
	case CORNER_BR:
		cinfo->x2 += deltax;
		cinfo->y2 += deltay;
		
		if (cinfo->x2 > (eth32.game.glconfig->vidWidth - 4))
			cinfo->x2 = eth32.game.glconfig->vidWidth - 4;
		else if ((cinfo->x2 - cinfo->x1) < CAM_MIN_SIZE)
			cinfo->x2 = cinfo->x1 + CAM_MIN_SIZE;

		if (cinfo->y2 > (eth32.game.glconfig->vidHeight - 4))
			cinfo->y2 = eth32.game.glconfig->vidHeight - 4;
		else if ((cinfo->y2 - cinfo->y1) < CAM_MIN_SIZE)
			cinfo->y2 = cinfo->y1 + CAM_MIN_SIZE;
		break;
	default:
		cinfo->x1 += deltax;
		cinfo->y1 += deltay;
		cinfo->x2 += deltax;
		cinfo->y2 += deltay;

		if (cinfo->x1 < 4) {
			int dx = 4 - cinfo->x1;
			cinfo->x1 += dx;
			cinfo->x2 += dx;
		}
		
		if (cinfo->y1 < 4) {
			int dy = 4 - cinfo->y1;
			cinfo->y1 += dy;
			cinfo->y2 += dy;
		}

		if (cinfo->x2 > (eth32.game.glconfig->vidWidth - 4)) {
			int dx = eth32.game.glconfig->vidWidth - 4 - cinfo->x2;
			cinfo->x1 += dx;
			cinfo->x2 += dx;
		}

		if (cinfo->y2 > (eth32.game.glconfig->vidHeight - 4)) {
			int dy = eth32.game.glconfig->vidHeight - 4 - cinfo->y2;
			cinfo->y1 += dy;
			cinfo->y2 += dy;
		}
		break;
	}
}

/*********************
* CCameraConfigWindow
**********************/

CCameraConfigWindow::CCameraConfigWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
		
	AddControl(new CDropbox("Camera Type", 5, 5, ww-10, 23, 0, CAM_MAX-1, &eth32.settings.camType, camTypeText));

	cam = &eth32.settings.cams[eth32.settings.camType];

	show = new CCheckBox("Show", 5, 33, ww-10, 8, &cam->display);
	AddControl(show);
	fov = new CFloatSlider("FOV", 5, 51, ww-10, 20, 30, 150, &cam->fov);
	AddControl(fov);
	distance = new CFloatSlider("Distance", 5, 76, ww-10, 20, 10, 2000, &cam->distance);
	AddControl(distance);
	angle = new CFloatSlider("Angle", 5, 101, ww-10, 20, 0, 90, &cam->angle);
	AddControl(angle);
	
}

void CCameraConfigWindow::Display(void)
{
	UpdateOffsets();

	cam = &eth32.settings.cams[eth32.settings.camType];

	switch(eth32.settings.camType)
	{
		case CAM_MORTAR:
		case CAM_TARGET:
		case CAM_SATCHEL:
		case CAM_DROP_ONE:
		case CAM_DROP_TWO:
		case CAM_DROP_THREE:
		case CAM_DROP_FOUR:
		{
			fov->Show(true);
			distance->Show(true);
			angle->Show(true);
			break;
		}
		case CAM_MIRROR:
		case CAM_ENEMY:
		{
			fov->Show(true);
			distance->Show(false);
			angle->Show(false);
			break;
		}
		case CAM_PANZER:
		case CAM_RIFLE:
		case CAM_FOLLOW:
		{
			fov->Show(true);
			distance->Show(true);
			angle->Show(false);
			break;
		}
		
		
		
		
		default:
			break;
	}

	CWindow::Display();
}

void CCameraConfigWindow::UpdateOffsets(void)
{
	cam = &eth32.settings.cams[eth32.settings.camType];

	show->SetTarget(&cam->display);
	distance->SetTarget(&cam->distance);
	angle->SetTarget(&cam->angle);
	fov->SetTarget(&cam->fov);
}// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"
#include "CSliders.h"
#include "CCheckbox.h"

#define CAM_MIN_SIZE	80

typedef enum {
	CORNER_TL,
	CORNER_TR,
	CORNER_BL,
	CORNER_BR
} corner_t;

class CCameraWindow : public CWindow
{
public:
	CCameraWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	int MouseWheel(int mx, int my, int wheel);
	void MouseMove(int mx, int my);
private:
	bool cameraActive;
	int cornerActive;
	int type;
};

class CCameraConfigWindow : public CWindow
{
public:
	CCameraConfigWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
private:
	void UpdateOffsets(void);
	camInfo_t *cam;

	int x, y, w, h;
	CCheckBox *show;
	CFloatSlider *distance, *angle, *fov;
};

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CChatWindow::CChatWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	showTitle = false;
	chatTarget = CHAT_NONE;

	inputOffset = (GUI_FONTHEIGHT + 8);

	ctrlBuffer = new CTextBuffer("chatbuffer", 5, 5, ww - 10, wh - 10, 512);
	ctrlInput = new CTextInput("chatinput", 5, wh + (5 + GUI_FONTHEIGHT) / eth32.cg.screenYScale, ww - 10, inputOffset / eth32.cg.screenYScale, MAX_SAY_TEXT+1, funcRouteChat);	// funcRouteChat() : see below

	inputOffset += (5 * eth32.cg.screenYScale) + 5 + GUI_FONTHEIGHT;

	lxOffset = (ww >> 1) * eth32.cg.screenXScale;
	lyOffset = wh * eth32.cg.screenYScale;
	lx = x + lxOffset;
	ly = y + lxOffset;

	ctrlInput->Show(false);

	AddControl((CControl*)ctrlBuffer);
	AddControl((CControl*)ctrlInput);
}

void CChatWindow::Display(void)
{
	char buf[MAX_STRING_CHARS];
	CWindow::Display();
	
	if (selected) {		// need to print our msg type
		if (chatTarget == CHAT_SAY)
			Draw.TextCenter(lx, ly, GUI_FONTSCALE, "say", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		else if (chatTarget == CHAT_TEAM)
			Draw.TextCenter(lx, ly, GUI_FONTSCALE, "team", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		else if (chatTarget == CHAT_FTEAM)
			Draw.TextCenter(lx, ly, GUI_FONTSCALE, "squad", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		else if (chatTarget == CHAT_PM){
			sprintf(buf, "pm ^3-> ^*%s", privmsgTarget);
			Draw.TextCenter(lx, ly, GUI_FONTSCALE, buf, GUI_FONTCOLOR1, qfalse, qfalse, GUI_FONT, true);
		} else if (chatTarget == CHAT_IRC) {
			CIrcWindow *ircwin = (CIrcWindow*)Gui.GetWinByTitle("IRC Frontend");
			if (ircwin) {
				char activeChannel[64];
				ircwin->GetActiveChannel(activeChannel,sizeof(activeChannel));
				sprintf(buf, "irc ^3-> ^*%s", activeChannel);
				Draw.TextCenter(lx, ly, GUI_FONTSCALE, buf, GUI_FONTCOLOR1, qfalse, qfalse, GUI_FONT, true);
			}
		}
	}
}

int CChatWindow::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (INBOUNDS(mx, my) && mevent == WM_LBUTTONDOWN && eth32.settings.nameClick && CheckNameClick(mx, my, khook))
		return 0;

	return CWindow::ProcessMouse(mx, my, mevent, mhook, khook);
}

int CChatWindow::ProcessKeybd(unsigned char key, CControl **khook)
{
	if (ctrlInput)
		ctrlInput->ProcessKeybd(key, khook);

	if (key == 0x1B || key == 0x0D)	{	// user pressed esc or enter, so rearrange window
		HideInputFocus();
		*khook = NULL;
	}
	return 0;
}

void CChatWindow::AddMessage(const char *msg)
{
	if (ctrlBuffer)
		ctrlBuffer->AddText(msg);
}

void CChatWindow::ShowInputFocus(void)
{
	if (!selected) {
		inputOffset = (GUI_FONTHEIGHT << 1) + (5 * eth32.cg.screenYScale) + 13;

		Resize(w, h + inputOffset);
		Reposition(x, y - inputOffset);

		ctrlInput->Show(true);
		ctrlInput->SetFocus();
		selected = true;
	}
}

void CChatWindow::HideInputFocus(void)
{
	if (selected) {
		Resize(w, h - inputOffset);
		Reposition(x, y + inputOffset);

		ctrlInput->Show(false);
		selected = false;
	}
}

void CChatWindow::SetTarget(chattype_t type, CControl **khook)
{
	chatTarget = type;
	
	if (chatTarget >= CHAT_SAY && chatTarget <= CHAT_PM) {
		ShowInputFocus();
		*khook = (CControl*)this;
	}
}

void CChatWindow::SetPrivMsgTarget(const char *target)
{
	if (target && *target) {
		strcpy(privmsgTarget, target);
	}
}

bool CChatWindow::CheckNameClick(int mx, int my, CControl **khook)
{
	if (ctrlBuffer) {
		const char *p = ctrlBuffer->GetTextClick(mx, my);
		char *end;

		if (!p)
			return false;
		
		int wordLength = (strchr(p, ' ')) ? strchr(p, ' ') - p : strlen(p);
		char word[MAX_SAY_TEXT];

		strncpy(word, p, wordLength);
		end = &word[wordLength-1];
		
		if (*end == ':') {
			*end = 0;
			end--;
		}

		if (Q_IsColorString(end - 1)) {
			*(end-1) = 0;
		}

		for (int i=0 ; i<MAX_CLIENTS ; i++)
		{
			player_t *plyr = &eth32.cg.players[i];
			if (*plyr->infoValid && (strstr(word, plyr->name) || strstr(plyr->name, word))) {
				strcpy(privmsgTarget, plyr->name);
				SetTarget(CHAT_PM, khook);
				return true;
			}
		}
	}
	return false;
}

// Utility text function
void funcRouteChat(const char *msg)
{
	char buf[MAX_STRING_CHARS];
	chattype_t type = Gui.GetChatTarget();

	switch (type)
	{
	case CHAT_SAY:
		sprintf(buf, "say \"%s\"\n", msg);
		Gui.BufferConsoleCommand(buf);
		break;
	case CHAT_TEAM:
		sprintf(buf, "say_team \"%s\"\n", msg);
		Gui.BufferConsoleCommand(buf);
		break;
	case CHAT_FTEAM:
		sprintf(buf, "say_buddy \"%s\"\n", msg);
		Gui.BufferConsoleCommand(buf);
		break;
	case CHAT_IRC:
		Irc.ParseUserInput(msg);
		break;
	case CHAT_PM:
		Gui.PrivateMessage(msg);
		break;
	default:
#ifdef ETH32_DEBUG
		Debug.Log("funcRouteChat() - Chat type %i not valid.", type);
#endif
		break;
	}
}


// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"
#include "CTextControls.h"

typedef enum 
{
	CHAT_NONE,
	CHAT_SAY,
	CHAT_TEAM,
	CHAT_FTEAM,
	CHAT_IRC,
	CHAT_PM,
	CHAT_MAX
} chattype_t;

class CChatWindow : public CWindow
{
public:
	CChatWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	int ProcessKeybd(unsigned char key, CControl **khook);
	
	void AddMessage(const char *msg);

	void ShowInputFocus(void);
	void HideInputFocus(void);

	void SetTarget(chattype_t type, CControl **khook);
	chattype_t GetTarget(void) { return chatTarget; }

	void SetPrivMsgTarget(const char *target);
	const char* PrivMsgTarget(void) { return privmsgTarget; }
private:
	bool CheckNameClick(int mx, int my, CControl **khook);

	chattype_t chatTarget;

	CTextBuffer *ctrlBuffer;
	CTextInput *ctrlInput;

	char privmsgTarget[128];

	int inputOffset;
};

// Utility text function
void funcRouteChat(const char *msg);
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

/*****************
* CCheckBox
*****************/

CCheckBox::CCheckBox(char *clabel, int cx, int cy, int cw, int ch, bool *ctarget)
: CControl(clabel, cx, cy, cw, ch)
{
	target = ctarget;
}

void CCheckBox::Display(void)
{
	Draw.Text(x, y, GUI_FONTSCALE, label, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.RawPic(x2 - h, y, h, h, eth32.guiAssets.checkBox);

	if (*target)
		Draw.RawPic(x2 - h, y, h, h, eth32.guiAssets.check);
}

int CCheckBox::ProcessMouse(int mx, int my, uint32 event, CControl **mhook, CControl **khook)
{
	if (INBOUNDS(mx,my)) {		// checking whole control area, maybe change to just box?
		if (event == WM_LBUTTONDOWN) 
			*target = !(*target);
		*mhook = *khook = NULL;
		return 0;
	}
	return 1;
}

void CCheckBox::SetTarget(bool *ctarget)
{
	target = ctarget;
}
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CControl.h"

class CCheckBox : public CControl
{
protected:
	bool *target;
public:
	CCheckBox(char *clabel, int cx, int cy, int cw, int ch, bool *ctarget);
	void Display(void);
	virtual int ProcessMouse(int mx, int my, uint32 event, CControl **mhook, CControl **khook);
	void SetTarget(bool *ctarget);
};

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

/************************
* CClientWindow
************************/

#define CLIENT_SPACING		((int)(2 * eth32.cg.screenYScale))

CClientWindow::CClientWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	locked = true;

	numTeam = numEnemy = numSpec = 0;
	selectedClientNum = -1;

	int totalUseableWidth = w - (GUI_SPACING * 3);
	leftPaneWidth = totalUseableWidth * 0.50;
	rightPaneWidth = totalUseableWidth - leftPaneWidth;

	InitClientButtons();

	lgFontScale = GUI_FONTSCALE * 2;
	lgFontSize = Draw.sizeTextHeight(lgFontScale, GUI_FONT);
}

CClientWindow::~CClientWindow(void)
{

}

void CClientWindow::Display(void)
{
	UpdateClients();
	
	CWindow::Display();

	DrawClientInfo();
	DrawClientButtons();

	if (selectedClientNum >= 0 && selectedClientNum < MAX_CLIENTS && IS_INFOVALID(selectedClientNum)) {
		// TODO: friend checking for button display
	}
	else
		selectedClientNum = -1;
}

int CClientWindow::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (INBOUNDS(mx,my)) {
		if (mevent == WM_LBUTTONDOWN && CheckClientSelect(mx,my))
			return 0;
		

	}
	return 1;
}

bool CClientWindow::CheckClientSelect(int mx, int my)
{
	for (int i=0 ; i<2 ; i++) {
		for (int j=0 ; j<32 ; j++) {
			clientButton_t *btn = &buttons[i][j];

			if (btn->valid && INBOUNDS2(mx,my,btn->x,btn->y,btn->x2,btn->y2)) {
				selectedClientNum = btn->clientNum;
				return true;
			}
		}
	}
	return false;
}

int CClientWindow::MouseWheel(int mx, int my, int wheel)
{
	return CWindow::MouseWheel(mx, my, wheel);
}

void CClientWindow::UpdateClients(void)
{
	numTeam = numEnemy = numSpec = 0;

	int cntCol1, cntCol2;
	cntCol1 = cntCol2 = 0;

	int specList[MAX_CLIENTS];
	clientButton_t *btn = NULL;

	ClearClients();
	
	for (int i=0 ; i<MAX_CLIENTS ; i++) {
		if (IS_INFOVALID(i)) {
			int team = *eth32.cg.players[i].team;

			if (IS_SPECTATOR(i)) {
				specList[numSpec] = i;
				numSpec++;
			} else if (IS_FRIENDLY(i)) {
				btn = &buttons[0][cntCol1];
				btn->clientNum = i;
				btn->valid = true;
				btn->type = CLIENT_TEAM;
				cntCol1++;
				numTeam++;
			} else {
				btn = &buttons[1][cntCol2];
				btn->clientNum = i;
				btn->valid = true;
				btn->type = CLIENT_ENEMY;
				cntCol2++;
				numEnemy++;
			}
		}
	}

	for (int i=0 ; i<numSpec ; i++) {
		btn = FindOpenSpecSlot();

		if (!btn)
			continue; // this shouldn't happen

		btn->clientNum = specList[i];
		btn->valid = true;
		btn->type = CLIENT_SPEC;
	}
}

void CClientWindow::ClearClients(void)
{
	for (int i=0 ; i<2 ; i++) {
		for (int j=0 ; j<32 ; j++) {
			clientButton_t *btn = &buttons[i][j];

			btn->valid = false;
			btn->clientNum = -1;
			btn->type = CLIENT_NONE;
		}
	}
}

void CClientWindow::InitClientButtons(void)
{
	int btnWidth = (rightPaneWidth - GUI_SPACING) / 2;
	int btnHeight = (h - GUI_TITLEBAR_SIZE - (GUI_SPACING * 2) - (CLIENT_SPACING * 31)) / 32;
	int xPos = x + GUI_SPACING + leftPaneWidth + GUI_SPACING;	

	for (int i=0 ; i<2 ; i++) {
		int yPos = y + GUI_TITLEBAR_SIZE + GUI_SPACING;
		for (int j=0 ; j<32 ; j++) {
			clientButton_t *btn = &buttons[i][j];

			btn->clientNum = -1;
			btn->type = CLIENT_NONE;
			btn->valid = false;
			btn->x = xPos;
			btn->y = yPos;
			btn->w = btnWidth;
			btn->h = btnHeight;
			btn->x2 = xPos + btnWidth;
			btn->y2 = yPos + btnHeight;

			yPos += btnHeight + CLIENT_SPACING;
		}
		xPos += btnWidth + GUI_SPACING;
	}
}

void CClientWindow::DrawClientButtons(void)
{
	vec4_t btnColor;

	for (int i=0 ; i<2 ; i++) {
		for (int j=0 ; j<32 ; j++) {
			clientButton_t *btn = &buttons[i][j];

			if (btn->valid) {
				bool selected = (btn->clientNum == selectedClientNum);

				if (btn->type == CLIENT_TEAM)
					Vector4Set(btnColor, eth32.settings.colorTeam[0] / 255.f, eth32.settings.colorTeam[1] / 255.f, eth32.settings.colorTeam[2] / 255.f, 1.0);
				else if (btn->type == CLIENT_ENEMY)
					Vector4Set(btnColor, eth32.settings.colorEnemy[0] / 255.f, eth32.settings.colorEnemy[1] / 255.f, eth32.settings.colorEnemy[2] / 255.f, 1.0);
				else 
					Vector4Copy(colorLtGrey, btnColor);

				Syscall.R_SetColor(btnColor);

				qhandle_t shader = eth32.cg.media.combtnLeft;

				Draw.RawPicST(btn->x, btn->y, 12, 6, 0, 0, 1, 0.5, shader);
				Draw.RawPicST(btn->x, btn->y+6, 12, btn->h-12, 0, .4, 1, 0.6, shader);
				Draw.RawPicST(btn->x, btn->y+btn->h-6, 12, 6, 0, 0.5, 1, 1, shader);
	
				shader = eth32.cg.media.combtnCenter;

				Draw.RawPicST(btn->x + 12, btn->y, btn->w - 24, 6, 0, 0, 1, 0.5, shader);
				Draw.RawPicST(btn->x + 12, btn->y+6, btn->w - 24, btn->h-12, 0, 0.4, 1, 0.6, shader);
				Draw.RawPicST(btn->x + 12, btn->y+btn->h-6, btn->w - 24, 6, 0, 0.5, 1, 1, shader);

				shader = eth32.cg.media.combtnRight;

				Draw.RawPicST(btn->x + btn->w - 12, btn->y, 12, 6, 0, 0, 1, 0.5, shader);
				Draw.RawPicST(btn->x + btn->w - 12, btn->y+6, 12, btn->h-12, 0, 0.4, 1, 0.6, shader);
				Draw.RawPicST(btn->x + btn->w - 12, btn->y+btn->h-6, 12, 6, 0, 0.5, 1, 1, shader);

				Syscall.R_SetColor(NULL);

				if (selectedClientNum == btn->clientNum) {
					Syscall.R_SetColor(colorYellow);

					qhandle_t shader = eth32.cg.media.comselLeft;

					Draw.RawPicST(btn->x, btn->y, 12, 6, 0, 0, 1, 0.5, shader);
					Draw.RawPicST(btn->x, btn->y+6, 12, btn->h-12, 0, .4, 1, 0.6, shader);
					Draw.RawPicST(btn->x, btn->y+btn->h-6, 12, 6, 0, 0.5, 1, 1, shader);
	
					shader = eth32.cg.media.comselCenter;

					Draw.RawPicST(btn->x + 12, btn->y, btn->w - 24, 6, 0, 0, 1, 0.5, shader);
					Draw.RawPicST(btn->x + 12, btn->y+6, btn->w - 24, btn->h-12, 0, 0.4, 1, 0.6, shader);
					Draw.RawPicST(btn->x + 12, btn->y+btn->h-6, btn->w - 24, 6, 0, 0.5, 1, 1, shader);

					shader = eth32.cg.media.comselRight;

					Draw.RawPicST(btn->x + btn->w - 12, btn->y, 12, 6, 0, 0, 1, 0.5, shader);
					Draw.RawPicST(btn->x + btn->w - 12, btn->y+6, 12, btn->h-12, 0, 0.4, 1, 0.6, shader);
					Draw.RawPicST(btn->x + btn->w - 12, btn->y+btn->h-6, 12, 6, 0, 0.5, 1, 1, shader);

					Syscall.R_SetColor(NULL);
				}

				player_t *player = &eth32.cg.players[btn->clientNum];

				int textX = btn->x + (btn->w >> 1);
				int textY = btn->y + ((btn->h - GUI_FONTHEIGHT) / 2.f);

				if (TEXTWIDTH(player->name) > (btn->w - 10)) {
					char tempName[256];
					int cnt = Draw.BreakStringByWidth(player->name, btn->w-10, NULL, GUI_FONT, false);
					strncpy(tempName, player->name, cnt);
					Draw.TextCenter(textX, textY, GUI_FONTSCALE, tempName, colorWhite, qtrue, qfalse, GUI_FONT, true);
				} else {
					Draw.TextCenter(textX, textY, GUI_FONTSCALE, player->name, colorWhite, qtrue, qfalse, GUI_FONT, true);
				}
			}
		}
	}
}

clientButton_t* CClientWindow::FindOpenSpecSlot(void)
{
	for (int i=31 ; i >= 0 ; i--) {
		if (!buttons[0][i].valid)
			return &buttons[0][i];
		
		if (!buttons[1][i].valid)
			return &buttons[1][i];
	}
	return NULL; // all full?? this should never happen
}

void CClientWindow::DrawClientInfo(void)
{
	if (selectedClientNum < 0 || selectedClientNum >= MAX_CLIENTS)
		return;

	if (!IS_INFOVALID(selectedClientNum)) {
		selectedClientNum = -1;
		return;
	}

	player_t *player = &eth32.cg.players[selectedClientNum];
	int xPos, yPos;
	char buffer[256];

	// draw name
	xPos = x + GUI_SPACING + (leftPaneWidth >> 1);
	yPos = y + GUI_TITLEBAR_SIZE + (GUI_SPACING*4);

	Draw.TextCenter(xPos, yPos, lgFontScale, player->name, GUI_FONTCOLOR1, qfalse, qfalse, GUI_FONT, true);
	yPos += lgFontSize + GUI_SPACING;

	Draw.TextCenter(xPos, yPos, GUI_FONTSCALE, "player name", GUI_FONTCOLOR2, qfalse, qfalse, GUI_FONT, true);
	yPos += GUI_FONTHEIGHT + (GUI_SPACING*5);

	// draw portal name
	if (player->eth32user) {
		Draw.TextCenter(xPos, yPos, lgFontScale, player->portalName, GUI_FONTCOLOR1, qfalse, qfalse, GUI_FONT, true);
		yPos += lgFontSize + GUI_SPACING;

		Draw.TextCenter(xPos, yPos, GUI_FONTSCALE, "portal username", GUI_FONTCOLOR2, qfalse, qfalse, GUI_FONT, true);
		yPos += GUI_FONTHEIGHT + (GUI_SPACING*5);
	}

	// draw basic stats - line 1 (kills, deaths, k/d ratio)
	xPos = x + GUI_SPACING + (leftPaneWidth / 6);
	// kills
	sprintf(buffer, "%i", player->stats.kills);
	Draw.TextCenter(xPos, yPos, lgFontScale, buffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.TextCenter(xPos, yPos+lgFontSize+GUI_SPACING, GUI_FONTSCALE, "kills", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	xPos += leftPaneWidth / 3;
	// deaths
	sprintf(buffer, "%i", player->stats.deaths);
	Draw.TextCenter(xPos, yPos, lgFontScale, buffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.TextCenter(xPos, yPos+lgFontSize+GUI_SPACING, GUI_FONTSCALE, "deaths", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	xPos += leftPaneWidth / 3;
	// k/d ratio
	sprintf(buffer, "%.3f", player->stats.kdRatio);
	Draw.TextCenter(xPos, yPos, lgFontScale, buffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.TextCenter(xPos, yPos+lgFontSize+GUI_SPACING, GUI_FONTSCALE, "k/d ratio", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	yPos += lgFontSize + GUI_SPACING + GUI_FONTHEIGHT + (GUI_SPACING*4);

	// draw basic stats - line 2 (rnds fired, rnds hit, acc)
	xPos = x + GUI_SPACING + (leftPaneWidth / 6);
	// rnds fired
	sprintf(buffer, "%i", player->stats.bulletsFired);
	Draw.TextCenter(xPos, yPos, lgFontScale, buffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.TextCenter(xPos, yPos+lgFontSize+GUI_SPACING, GUI_FONTSCALE, "rounds fired", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	xPos += leftPaneWidth / 3;
	// rnds hit
	sprintf(buffer, "%i", player->stats.bulletsHit);
	Draw.TextCenter(xPos, yPos, lgFontScale, buffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.TextCenter(xPos, yPos+lgFontSize+GUI_SPACING, GUI_FONTSCALE, "rounds hit", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	xPos += leftPaneWidth / 3;
	// accuracy
	sprintf(buffer, "%.3f%%", player->stats.accuracy);
	Draw.TextCenter(xPos, yPos, lgFontScale, buffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.TextCenter(xPos, yPos+lgFontSize+GUI_SPACING, GUI_FONTSCALE, "accuracy", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	yPos += lgFontSize + GUI_SPACING + GUI_FONTHEIGHT + (GUI_SPACING*4);

	// draw basic stats - line 3 (suicides, current spree, longest spree)
	xPos = x + GUI_SPACING + (leftPaneWidth / 6);
	// suicides
	sprintf(buffer, "%i", player->stats.suicides);
	Draw.TextCenter(xPos, yPos, lgFontScale, buffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.TextCenter(xPos, yPos+lgFontSize+GUI_SPACING, GUI_FONTSCALE, "suicides", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	xPos += leftPaneWidth / 3;
	// current spree
	sprintf(buffer, "%i", player->stats.spree);
	Draw.TextCenter(xPos, yPos, lgFontScale, buffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.TextCenter(xPos, yPos+lgFontSize+GUI_SPACING, GUI_FONTSCALE, "cur spree", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	xPos += leftPaneWidth / 3;
	// max spree
	sprintf(buffer, "%i", player->stats.longestSpree);
	Draw.TextCenter(xPos, yPos, lgFontScale, buffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.TextCenter(xPos, yPos+lgFontSize+GUI_SPACING, GUI_FONTSCALE, "max spree", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	yPos += lgFontSize + GUI_SPACING + GUI_FONTHEIGHT + (GUI_SPACING*4);

	// draw basic stats - line 4 (threat)
	xPos = x + GUI_SPACING + (leftPaneWidth >> 1);
	// threat
	sprintf(buffer, "%.3f", player->stats.threat);
	Draw.TextCenter(xPos, yPos, lgFontScale, buffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.TextCenter(xPos, yPos+lgFontSize+GUI_SPACING, GUI_FONTSCALE, "threat", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

}





	// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"
#include "CScrollBar.h"
#include "CButtons.h"

typedef enum {
	CLIENT_NONE,
	CLIENT_TEAM,
	CLIENT_ENEMY,
	CLIENT_SPEC
} clientType_t;

typedef struct {
	int x, y, x2, y2;
	int w, h;
	int clientNum;
	bool valid;
	clientType_t type;
} clientButton_t;

class CClientWindow : public CWindow
{
public:
	CClientWindow(char *wlabel, int wx, int wy, int ww, int wh);
	~CClientWindow(void);

	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	int MouseWheel(int mx, int my, int wheel);
	void SetProps(const char *props, float xScale, float yScale) {   }
private:
	bool CheckClientSelect(int mx, int my);
	void UpdateClients(void);
	void ClearClients(void);

	void InitClientButtons(void);
	void DrawClientButtons(void);
	clientButton_t* FindOpenSpecSlot(void);
	void DrawClientInfo(void);

	int selectedClientNum;

	clientButton_t	buttons[2][32];
	int numTeam, numEnemy, numSpec;

	int leftPaneWidth, rightPaneWidth;
	float lgFontScale;
	int	lgFontSize;
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CColorPicker::CColorPicker(char *clabel, int cx, int cy, int cw, int ch)
: CControl(clabel, cx, cy, cw, ch)
{
	currentColor = 0;
	numColors = 0;
	colorText = NULL;
	colorList = NULL;

	ctrlDropbox = new CDropbox("Current", 0, 0, cw - ch - 5, 23, 0, 0, &currentColor);
	ctrlDropbox->SetOrigin(x, y);
}

void CColorPicker::Display(void)
{
	if (!numColors)
		return;

	vec4_t targetColor;

	colorptr_t *color = &colorList[currentColor];

	if (color->bColor)
		VectorSet(targetColor, color->bColor[0]/255.f, color->bColor[1]/255.f, color->bColor[2]/255.f);
	else 
		VectorCopy(color->fColor, targetColor);

	targetColor[3] = 1.f;

	int drawY = 28 * eth32.cg.screenYScale;
	
	Draw.RawFillRect(x2 - h, y, h, h, targetColor);
	Draw.RawPic(x, y + drawY, w - h - GUI_SPACING, h - drawY, eth32.cg.media.colorTable);

	ctrlDropbox->Display();
}

int CColorPicker::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (INBOUNDS(mx, my)) {
		if (!ctrlDropbox->ProcessMouse(mx, my, mevent, mhook, khook))
			return 0;

		mx -= 2;
		my -= 1;
		if (INBOUNDS2(mx + 1, my, x, y + (28 * eth32.cg.screenYScale), x + (w - h - GUI_SPACING), y2)) {
			if (mevent == WM_LBUTTONDOWN) {
				if (colorList[currentColor].bColor)
					glReadPixels(mx, eth32.game.glconfig->vidHeight - my, 1, 1, GL_RGB, GL_UNSIGNED_BYTE, colorList[currentColor].bColor);
				else 
					glReadPixels(mx, eth32.game.glconfig->vidHeight - my, 1, 1, GL_RGB, GL_FLOAT, colorList[currentColor].fColor);
					
				*mhook = this;
				return 0;
			}
		}
		return 0;
	}
	return 1;
}

void CColorPicker::MouseMove(int mx, int my)
{
	mx -= 1;
	my -= 1;
	if (INBOUNDS2(mx + 1, my, x, y + (28 * eth32.cg.screenYScale), x + (w - h - GUI_SPACING), y2)) {
		if (colorList[currentColor].bColor)
			glReadPixels(mx, eth32.game.glconfig->vidHeight - my, 1, 1, GL_RGB, GL_UNSIGNED_BYTE, colorList[currentColor].bColor);
		else 
			glReadPixels(mx, eth32.game.glconfig->vidHeight - my, 1, 1, GL_RGB, GL_FLOAT, colorList[currentColor].fColor);
	}
}

void CColorPicker::Reposition(int cx, int cy)
{
	CControl::Reposition(cx, cy);
	ctrlDropbox->SetOrigin(x, y);
}

void CColorPicker::SetOrigin(int ox, int oy)
{
	CControl::SetOrigin(ox, oy);
	ctrlDropbox->SetOrigin(x, y);
}

void CColorPicker::AddColor(char *colorName, uchar *color)
{
	if (!colorName || !*colorName || !color)
		return;

	CreateNewEntry(colorName, color, NULL);
}

void CColorPicker::AddColor(char *colorName, float *color)
{
	if (!colorName || !*colorName || !color)
		return;

	CreateNewEntry(colorName, NULL, color);
}

void CColorPicker::CreateNewEntry(char *colorName, uchar *bColor, float *fColor)
{
	colorptr_t *tempList = new colorptr_t[numColors+1];
	char **tempText = new char*[numColors+1];

	if (numColors) {
		memcpy(tempList, colorList, sizeof(colorptr_t) * numColors);
		memcpy(tempText, colorText, sizeof(char*) * numColors);

		delete [] colorList;
		delete [] colorText;
	}

	colorList = tempList;
	colorText = tempText;

	colorList[numColors].bColor = bColor;
	colorList[numColors].fColor = fColor;
	colorText[numColors] = new char[strlen(colorName)+1];
	strcpy(colorText[numColors], colorName);

	ctrlDropbox->SetText((const char**)colorText);
	ctrlDropbox->SetMin(0);
	ctrlDropbox->SetMax(numColors);

	numColors++;
}
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CSliders.h"

typedef struct
{
	uchar *bColor;
	float *fColor;
} colorptr_t;

class CColorPicker : public CControl
{
public:
	CColorPicker(char *clabel, int cx, int cy, int cw, int ch);
	~CColorPicker(void);
	void Display(void);
	virtual int ProcessMouse(int mx, int my, uint32 event, CControl **mhook, CControl **khook);
	virtual void MouseMove(int mx, int my);
	void Reposition(int cx, int cy);
	void SetOrigin(int ox, int oy);
	void AddColor(char *colorName, uchar *color);
	void AddColor(char *colorName, float *color);
protected:
	void CreateNewEntry(char *colorName, uchar *bColor, float *fColor);
	int currentColor;
	int numColors;
	char **colorText;
	colorptr_t *colorList;
	CDropbox *ctrlDropbox;
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

//**********************
// CControl
//**********************

CControl::CControl(const char *clabel, int cx, int cy, int cw, int ch) // x,y,w,h in 640x480 for layout purposes, convert to real res
{
	label = new char[strlen(clabel)+1];
	strcpy(label, clabel);
	
	x = xOffset = cx * eth32.cg.screenXScale;
	y = yOffset = cy * eth32.cg.screenYScale;
	lx = lxOffset = cx;
	ly = lyOffset = cy;
	w = cw * eth32.cg.screenXScale;
	h = ch * eth32.cg.screenYScale;
	x2 = x + w;
	y2 = y + h;

	show = true;
	selected = false;
}

char *CControl::GetLabel(char *s, size_t s_s)
{
	strcpy(s, label);
	return s;
}

CControl::~CControl(void)
{
	delete [] label;
}

void CControl::Display(void)
{
}

int CControl::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (INBOUNDS(mx,my))
		return 0;
	else
		return 1;
}

int CControl::ProcessKeybd(unsigned char key, CControl **khook)
{
	return 0;
}

int CControl::MouseWheel(int mx, int my, int wheel)
{
	return 1;
}

void CControl::MouseMove(int mx, int my)
{
}

void CControl::Refresh(void)
{
}

void CControl::ClearFocus(void)
{
}

void CControl::Reposition(int cx, int cy) // cx, cy in true resolution
{
	x = xOffset = cx;
	y = yOffset = cy;
	lx = x + lxOffset;
	ly = y + lyOffset;

	x2 = x + w;
	y2 = y + h;
}

void CControl::Resize(int cw, int ch)
{
	w = cw;
	h = ch;

	x2 = x + w;
	y2 = y + h;
}

void CControl::SetOrigin(int ox, int oy)
{
	x = ox + xOffset;
	y = oy + yOffset;
	x2 = x + w;
	y2 = y + h;
	lx = x + lxOffset;
	ly = y + lyOffset;
}

void CControl::SetMouseFocus(bool set)
{

}

void CControl::SetKeybdFocus(bool set)
{
	
}

bool CControl::CaptureEscapeCharacter(void)
{
	// default for most keybd hooking controls
	return true;
}

void CControl::Show(bool enable)
{
	show = enable;
}

void CControl::SetLabel(const char *newLabel)
{
	if (newLabel && *newLabel) {
		delete [] label;
		label = new char[strlen(newLabel)+1];
		strcpy(label, newLabel);
	}
}

//**********************
// CIntDisplay
//**********************

CIntDisplay::CIntDisplay(char *clabel, int cx, int cy, int cw, int ch, int *ctarget)
: CControl(clabel, cx, cy, cw, ch)
{
	target = ctarget;
}

void CIntDisplay::Display(void)
{
	char txt[16];
	sprintf(txt, "%i", *target);

	Draw.Text(x, y, GUI_FONTSCALE, label, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - Draw.sizeTextWidth(GUI_FONTSCALE, txt, GUI_FONT), y, GUI_FONTSCALE, txt, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
}

//**********************
// CIntDisplay
//**********************

CFloatDisplay::CFloatDisplay(char *clabel, int cx, int cy, int cw, int ch, float *ctarget)
: CControl(clabel, cx, cy, cw, ch)
{
	target = ctarget;
}

void CFloatDisplay::Display(void)
{
	char txt[16];
	sprintf(txt, "%.2f", *target);

	Draw.Text(x, y, GUI_FONTSCALE, label, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - Draw.sizeTextWidth(GUI_FONTSCALE, txt, GUI_FONT), y, GUI_FONTSCALE, txt, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
}// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

class CControl
{
public:
	CControl(const char *clabel, int cx, int cy, int cw, int ch);
	~CControl(void);

	// Draw function
	virtual void Display(void);
	// Default handlers for mouse & keybd input
	virtual int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	virtual int ProcessKeybd(unsigned char key, CControl **khook);
	virtual int MouseWheel(int mx, int my, int wheel);
	virtual void MouseMove(int mx, int my);
	// Utility functions
	int Width(void) { return w; }
	int Height(void) { return h; }
	virtual void Refresh(void);
	virtual void ClearFocus(void);
	virtual void Reposition(int cx, int cy);
	virtual void Resize(int cw, int ch);
	virtual void SetOrigin(int ox, int oy);

	virtual void SetMouseFocus(bool set);
	virtual void SetKeybdFocus(bool set);
	// Used by text controls, tells GUI if they will process ESC or let GUI use it
	virtual bool CaptureEscapeCharacter(void);

	void SetLabel(const char *newLabel);
	char *GetLabel(char *s, size_t s_s);
	void Show(bool enable);
	// Our links to other controls
	CControl *prev, *next;
protected:
	char *label;			// text to be displayed with control (windows derived from this will use label as title)

	int x, y;				// abs control position
	int x2, y2;				// bottom right corner
	int xOffset, yOffset;	// relative position to parent

	int w, h;				// width and height of control

	int lx, ly;				// abs label position
	int lxOffset, lyOffset; // rel label position

	bool selected;
	bool show;
};

class CIntDisplay : public CControl
{
private:
	int *target;
public:
	CIntDisplay(char *clabel, int cx, int cy, int cw, int ch, int *ctarget);
	void Display(void);
};

class CFloatDisplay : public CControl
{
private:
	float *target;
public:
	CFloatDisplay(char *clabel, int cx, int cy, int cw, int ch, float *ctarget);
	void Display(void);
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CEspConfigWindow::CEspConfigWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
		
	int yPos = (GUI_FONTPIXELHEIGHT * 2) - 10;


	AddControl(new CDropbox("Player Esp Style", 5, yPos, ww-10, 23, 0, ESP_PLAYER_MAX-1, &eth32.settings.playerEspType, playerEspText));
	yPos += 28;
	
	pName = new CCheckBox("Player Names", 5, yPos, ww-10, 8, &eth32.settings.espName);
	AddControl(pName);
	yPos += 13;

	pTracker = new CCheckBox("Tracker Names", 5, yPos, ww-10, 8, &eth32.settings.espTracker);
	AddControl(pTracker);
	yPos += 13;

	pTrackerIcon = new CCheckBox("Tracker Icons", 5, yPos, ww-10, 8, &eth32.settings.iconTracker);
	AddControl(pTrackerIcon);
	yPos += 13;

	pTrackerIcon = new CCheckBox("Crosshair Info", 5, yPos, ww-10, 8, &eth32.settings.xhairInfo);
	AddControl(pTrackerIcon);
	yPos += 13;

	pInfoTime = new CIntSlider("Info Time (msec)", 5, yPos, ww-10, 20, 0, 3000, &eth32.settings.xhairInfoTime);
	AddControl(pInfoTime);
	yPos += 25;

	if(eth32.cgMod->type != MOD_TCE) 
	{
		AddControl(new CDropbox("Gentity Type", 5, yPos, ww-10, 23, 0, ESP_GENT_MAX-1, &eth32.settings.gentitySetting, gentityEspText));
		yPos += 28;
	}
	else
	{
		AddControl(new CDropbox("Gentity Type", 5, yPos, ww-10, 23, 0, ESP_GENT_TCE_MAX-1, &eth32.settings.gentitySetting, gentityEspTextTCE));
		yPos += 28;
	}
	gent = &eth32.settings.gentInfo[eth32.settings.gentitySetting];

	gCham = new CCheckBox("Chams", 5, yPos, ww-10, 8, &gent->chams);
	AddControl(gCham);
	yPos += 13;

	gText = new CCheckBox("Text", 5, yPos, ww-10, 8, &gent->text);
	AddControl(gText);
	yPos += 13;

	gIcon = new CCheckBox("Icon", 5, yPos, ww-10, 8, &gent->icon);
	AddControl(gIcon);
	yPos += 13;

	gRadarIcon = new CCheckBox("Radar Icon", 5, yPos, ww-10, 8, &gent->radarIcon);
	AddControl(gRadarIcon);
	yPos += 13;

	gDistance = new CIntSlider("Distance", 5, yPos, ww-10, 20, 0, 5000, &gent->distance);
	AddControl(gDistance);
	
}

void CEspConfigWindow::Display(void)
{
	UpdateOffsets();

	
	CWindow::Display();
}

void CEspConfigWindow::UpdateOffsets(void)
{

	gent = &eth32.settings.gentInfo[eth32.settings.gentitySetting];
	gCham->SetTarget(&gent->chams);
	gText->SetTarget(&gent->text);
	gIcon->SetTarget(&gent->icon);
	gRadarIcon->SetTarget(&gent->radarIcon);
	gDistance->SetTarget(&gent->distance);

	
}

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"
#include "CCheckbox.h"
#include "CSliders.h"

class CEspConfigWindow : public CWindow
{
public:
	CEspConfigWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
private:
	void UpdateOffsets(void);
	gentityInfo_t *gent;

	int x, y, w, h;
	CCheckBox *pName, *pTracker, *pTrackerIcon, *pCrosshairInfo, *gRadarIcon, *gCham, *gIcon, *gText;
	CIntSlider *pInfoTime, *gDistance;
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CEspWindow::CEspWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	showTitle = false;
	show = eth32.settings.xhairInfo;
	barSize = 6 * eth32.cg.screenYScale;
	barPadding = 4 * eth32.cg.screenYScale;

	lxOffset = (ww >> 1) * eth32.cg.screenXScale;
	lx = x + lxOffset;

	// temp hack to size window right
	Resize(w, (10 * eth32.cg.screenYScale) + (GUI_FONTHEIGHT * 7) + (GUI_TEXTSPACING * 9));

	timeStart = 0;
	displayClientNum = 0;
}

void CEspWindow::Display(void)
{
	if (!eth32.settings.xhairInfo)
		return;

	uint32 u = Time();

	if (eth32.cg.xhairClientNum > -1) {
		show = true;
		displayClientNum = eth32.cg.xhairClientNum;
		timeStart = u;
	}
	else if (displayClientNum > -1 && (u - timeStart) < eth32.settings.xhairInfoTime) {
		show = true;
	}
	else {
		show = false;
		timeStart = 0;
	}

	if (show) {
		CWindow::Display();

		player_t *player = &eth32.cg.players[displayClientNum];

		int cnt = Draw.BreakStringByWidth(player->name, w-10, NULL, GUI_FONT, false);
		if (cnt > 0 && cnt < sizeof(name))
			strncpy(name, player->name, cnt);
		else
			return;

		int drawX = x + 5 * eth32.cg.screenXScale;
		int drawY = y + 5 * eth32.cg.screenYScale;
		int drawX2 = x2 - 5 * eth32.cg.screenXScale;

		char p[16];

		Draw.TextCenter(lx, drawY, GUI_FONTSCALE, name, colorWhite, qfalse, qfalse, GUI_FONT, true);
		
		drawY += GUI_FONTHEIGHT + barPadding;

		if (IS_SPECTATOR(eth32.cg.clientNum) || IS_FRIENDLY(displayClientNum)) {
			float healthFrac = *player->health / 100.f;
			if (healthFrac > 1.0)
				healthFrac = 1.0;

			vec4_t healthColor;
			Draw.ColorForHealth(*player->health, healthColor);
			Draw.Statbar(x+GUI_SPACING, drawY, w-GUI_SPACING-GUI_SPACING, barSize, healthFrac, healthColor);
		}

		drawY += barSize + barPadding;

		sprintf(p, "%.2f", player->stats.kdRatio);
		Draw.Text(drawX, drawY, GUI_FONTSCALE, "K/D Ratio", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		Draw.Text(drawX2 - Draw.sizeTextWidth(GUI_FONTSCALE, p, GUI_FONT), drawY, GUI_FONTSCALE, p, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

		drawY += GUI_FONTHEIGHT + GUI_TEXTSPACING;

		//p = va("%i", player->stats.kills);
		//Draw.Text(drawX, drawY, GUI_FONTSCALE, "Kills", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		//Draw.Text(drawX2 - Draw.sizeTextWidth(GUI_FONTSCALE, p, GUI_FONT), drawY, GUI_FONTSCALE, p, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

		//drawY += GUI_FONTHEIGHT + GUI_TEXTSPACING;

		//p = va("%i", player->stats.deaths);
		//Draw.Text(drawX, drawY, GUI_FONTSCALE, "Deaths", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		//Draw.Text(drawX2 - Draw.sizeTextWidth(GUI_FONTSCALE, p, GUI_FONT), drawY, GUI_FONTSCALE, p, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

		//drawY += GUI_FONTHEIGHT + GUI_TEXTSPACING;
		sprintf(p, "%i", player->stats.suicides);
		Draw.Text(drawX, drawY, GUI_FONTSCALE, "Suicides", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		Draw.Text(drawX2 - Draw.sizeTextWidth(GUI_FONTSCALE, p, GUI_FONT), drawY, GUI_FONTSCALE, p, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

		drawY += GUI_FONTHEIGHT + GUI_TEXTSPACING;

		sprintf(p, "%i", player->stats.spree);
		Draw.Text(drawX, drawY, GUI_FONTSCALE, "Spree", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		Draw.Text(drawX2 - Draw.sizeTextWidth(GUI_FONTSCALE, p, GUI_FONT), drawY, GUI_FONTSCALE, p, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

		drawY += GUI_FONTHEIGHT + GUI_TEXTSPACING;

		if (player->stats.bulletsFired)
			sprintf(p, "%.1f", ((float)player->stats.bulletsHit/player->stats.bulletsFired)*100.f);
		else strcpy(p, "0.0");
		Draw.Text(drawX, drawY, GUI_FONTSCALE, "Accuracy", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		Draw.Text(drawX2 - Draw.sizeTextWidth(GUI_FONTSCALE, p, GUI_FONT), drawY, GUI_FONTSCALE, p, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

		drawY += GUI_FONTHEIGHT + GUI_TEXTSPACING;

		sprintf(p, "%.1f", player->stats.threat);
		Draw.Text(drawX, drawY, GUI_FONTSCALE, "Threat", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		Draw.Text(drawX2 - Draw.sizeTextWidth(GUI_FONTSCALE, p, GUI_FONT), drawY, GUI_FONTSCALE, p, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	}
}
		


		
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"

class CEspWindow : public CWindow
{
public:
	CEspWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
private:
	uint32 timeStart;
	int displayClientNum;
	char name[128];
	int barSize, barPadding;
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

/***********************
* CIrcUserList
***********************/

CIrcUserList::CIrcUserList(int cx, int cy, int cw, int ch)
: CControl("userlist", cx, cy, cw, ch)
{
	userlist.clear();
	scrollbar = new CScrollBar("scrollbar", cw - GUI_SCROLLBAR_WIDTH - GUI_SPACING, GUI_SPACING, ch - (GUI_SPACING * 2), 0, 0, true);
	scrollbar->SetOrigin(x, y);
	scrollbar->SetMaxDisplayItems( (h - 10) / (GUI_FONTHEIGHT + GUI_TEXTSPACING));
	userCount = 0;
}

CIrcUserList::~CIrcUserList(void)
{
	userlist.clear();
	delete scrollbar;
}

void CIrcUserList::Display(void)
{
	int yOff = 0;

	Draw.RawPic(x, y, GUI_ESIZE, GUI_ESIZE, eth32.guiAssets.winTopLeft);
	Draw.RawPic(x + GUI_ESIZE, y, w - (GUI_ESIZE+GUI_ESIZE), GUI_ESIZE, eth32.guiAssets.winTop);
	Draw.RawPicST(x2 - GUI_ESIZE, y, GUI_ESIZE, GUI_ESIZE, 1.f, 0.f, 0.f, 1.f, eth32.guiAssets.winTopLeft);

	yOff += GUI_ESIZE;

	Draw.RawPic(x, y + yOff, GUI_ESIZE, h - GUI_ESIZE - yOff, eth32.guiAssets.winLeft);
	Draw.RawPic(x + GUI_ESIZE, y + yOff, w - (GUI_ESIZE+GUI_ESIZE), h - GUI_ESIZE - yOff, eth32.guiAssets.winCenter);
	Draw.RawPicST(x2 - GUI_ESIZE, y + yOff, GUI_ESIZE, h - GUI_ESIZE - yOff, 1.f, 0.f, 0.f, 1.f, eth32.guiAssets.winLeft);

	Draw.RawPicST(x, y2 - GUI_ESIZE, GUI_ESIZE, GUI_ESIZE, 0.f, 1.f, 1.f, 0.f, eth32.guiAssets.winTopLeft);
	Draw.RawPicST(x + GUI_ESIZE, y2 - GUI_ESIZE, w - (GUI_ESIZE+GUI_ESIZE), GUI_ESIZE, 0.f, 1.f, 1.f, 0.f, eth32.guiAssets.winTop);
	Draw.RawPicST(x2 - GUI_ESIZE, y2 - GUI_ESIZE, GUI_ESIZE, GUI_ESIZE, 1.f, 1.f, 0.f, 0.f, eth32.guiAssets.winTopLeft);

	if (!userlist.empty()) {
		int drawX = x+5;
		int drawY = y+5;

		list<ircuser_t*>::iterator user_iter = userlist.begin();

		char nameBuffer[64];
		char tempColor;
		int charCount;
		int breakWidth = (scrollbar->IsActive()) ? w - 10 - scrollbar->Width() - GUI_SPACING : w - 10;

		if (scrollbar->IsActive()) {
			int startPos = scrollbar->GetCurrentItemNum();
			while (startPos != 0) {
				startPos--;
				user_iter++;
			}
		}
		
		while (user_iter != userlist.end() && (drawY + GUI_FONTHEIGHT + 5) < y2)
		{
			charCount = Draw.BreakStringByWidth((*user_iter)->display, breakWidth, &tempColor, GUI_FONT, false);

			if (charCount < strlen((*user_iter)->display)) {
				strncpy(nameBuffer, (*user_iter)->display, charCount);
				Draw.Text(drawX, drawY, GUI_FONTSCALE, nameBuffer, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
			}
			else Draw.Text(drawX, drawY, GUI_FONTSCALE, (*user_iter)->display, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
			
			drawY += GUI_FONTHEIGHT + 5;

			user_iter++;
		}
		scrollbar->Display();
	}
}

int CIrcUserList::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	return scrollbar->ProcessMouse(mx, my, mevent, mhook, khook);
}

void CIrcUserList::Resize(int cw, int ch)
{
	CControl::Resize(cw, ch);

	scrollbar->Reposition(w - scrollbar->Width() - GUI_SPACING, GUI_SPACING);
	scrollbar->Resize(scrollbar->Width(), h - GUI_SPACING - GUI_SPACING);
	scrollbar->SetOrigin(x, y);
	scrollbar->SetMaxDisplayItems( (h - 10) / (GUI_FONTHEIGHT + 5));
}

void CIrcUserList::Reposition(int cx, int cy)
{
	CControl::Reposition(cx, cy);
	
	scrollbar->SetOrigin(x, y);
}

void CIrcUserList::SetOrigin(int ox, int oy)
{
	CControl::SetOrigin(ox, oy);

	scrollbar->SetOrigin(x, y);
}

ircuser_t* CIrcUserList::CreateIrcUser(const char *nick)
{
	ircuser_t *user = new ircuser_t;
	user->opStatus = 0;

	bool adjNick = false;

	if (nick[0] == '~') {
		user->opStatus = IRCUSER_OWNER;
		adjNick = true;
	}
	else if (nick[0] == '&') {
		user->opStatus = IRCUSER_PROTECTED;
		adjNick = true;
	}
	else if (nick[0] == '@') {
		user->opStatus = IRCUSER_OP;
		adjNick = true;
	}
	else if (nick[0] == '%') {
		user->opStatus = IRCUSER_HALFOP;
		adjNick = true;
	}
	else if (nick[0] == '+') {
		user->opStatus = IRCUSER_VOICE;
		adjNick = true;
	}
	else user->opStatus = IRCUSER_NORMAL;
	
	if (adjNick) {
		user->nick = new char[strlen(&nick[1])+1];
		strcpy(user->nick, &nick[1]);
	}
	else {
		user->nick = new char[strlen(nick)+1];
		strcpy(user->nick, nick);
	}
	user->display = new char[strlen(nick)+1];
	strcpy(user->display, nick);

	return user;
}	

ircuser_t* CIrcUserList::GetIrcUser(const char *nick)
{
	if (userlist.empty())
		return NULL;

	for (list<ircuser_t*>::iterator user = userlist.begin() ; user != userlist.end() ; user++)
	{
		if (!strcmp((*user)->nick, nick))
			return *user;
	}
	// not found
	return NULL;
}

void CIrcUserList::DestroyIrcUser(ircuser_t *user)
{
	if (user) {
		delete [] user->nick;
		delete [] user->display;
		delete user;
	}
}

void CIrcUserList::InsertUser(ircuser_t *user)
{
	if (userlist.empty() || UserHigher(user, userlist.front())) {
		userlist.push_front(user);
		return;
	}

	list<ircuser_t*>::iterator user_next;
	for (list<ircuser_t*>::iterator user_iter = userlist.begin() ; user_iter != userlist.end() ; user_iter++)
	{
		user_next = user_iter;
		user_next++;
		if (user_next != userlist.end()) {
			if (UserHigher(user, *user_next)) {
				userlist.insert(user_next, user);
				return;
			}
		}
		else {
			userlist.push_back(user);
			return;
		}
	}
}

void CIrcUserList::RemoveUser(ircuser_t *user)
{
	for (list<ircuser_t*>::iterator user_iter = userlist.begin() ; user_iter != userlist.end() ; user_iter++)
	{
		if (*user_iter == user) {
			userlist.erase(user_iter);
			return;
		}
	}
}

bool CIrcUserList::UserHigher(ircuser_t *thisUser, ircuser_t *otherUser)
{
	if (thisUser->opStatus > otherUser->opStatus)
		return true;

	if (thisUser->opStatus == otherUser->opStatus) 
		return (strcasecmp(thisUser->nick, otherUser->nick) < 0);

	return false;
}

bool CIrcUserList::AddUser(const char *nick)
{
	if (!nick || !*nick) 
		return false;

	ircuser_t *user = CreateIrcUser(nick);
	InsertUser(user);
	userCount++;
	scrollbar->SetNumCurrentItems(userCount);
	return true;
}

bool CIrcUserList::RemoveUser(const char *nick)
{
	if (!userlist.empty() && nick && *nick) {
		for (list<ircuser_t*>::iterator user_iter = userlist.begin() ; user_iter != userlist.end() ; user_iter++)
		{
			if (!strcmp(nick, (*user_iter)->nick)) {
				DestroyIrcUser(*user_iter);
				userlist.erase(user_iter);
				userCount--;
				scrollbar->SetNumCurrentItems(userCount);
				return true;

			}
		}
	}
	return false;
}

bool CIrcUserList::ChangeUserMode(const char *nick, const char *modeStr)
{
	ircuser_t *user = GetIrcUser(nick);

	// user not found
	if (!user)
		return false;

	bool opAdd = (modeStr[0] == '+');

	for (int k=1 ; modeStr[k] ; k++)
	{
		unsigned int mode = 0;

		switch (modeStr[k])
		{
		case 'q':
			mode = IRCUSER_OWNER;
			break;
		case 'a':
			mode = IRCUSER_PROTECTED;
			break;
		case 'o':
			mode = IRCUSER_OP;
			break;
		case 'h':
			mode = IRCUSER_HALFOP;
			break;
		case 'v':
			mode = IRCUSER_VOICE;
			break;
		// other types can be added here, though I don't know them off hand
		}

		if (opAdd) 
			user->opStatus |= mode;
		else 
			user->opStatus &= ~mode;
	}

	if (user->opStatus & ~IRCUSER_NORMAL) // something other than normal user
		user->opStatus &= ~IRCUSER_NORMAL;

	FixDisplayNick(user);
	// remove user and reinsert in proper order
	RemoveUser(user);
	InsertUser(user);

	return true;
}

void CIrcUserList::FixDisplayNick(ircuser_t *user)
{
	delete [] user->display;

	if (user->opStatus & IRCUSER_NORMAL) {
		user->display = new char[strlen(user->nick)+1];
		strcpy(user->display,  user->nick);
		return;
	}

	char opChar = 0;
	
	if (user->opStatus & IRCUSER_OWNER)
		opChar = '~';
	else if (user->opStatus & IRCUSER_PROTECTED)
		opChar = '&';
	else if (user->opStatus & IRCUSER_OP)
		opChar = '@';
	else if (user->opStatus & IRCUSER_HALFOP)
		opChar = '%';
	else if (user->opStatus & IRCUSER_VOICE)
		opChar = '+';
	
	if (opChar) {
		user->display = new char[strlen(user->nick)+2];
		user->display[0] = opChar;
		strcpy(&user->display[1], user->nick);
	}
	else {  // not sure what this is, so assign nick like normal user
		user->display = new char[strlen(user->nick)+1];
		strcpy(user->display, user->nick);
	}
}

bool CIrcUserList::NickChange(const char *oldNick, const char *newNick)
{
	for (list<ircuser_t*>::iterator user_iter = userlist.begin() ; user_iter != userlist.end() ; user_iter++)
	{
		if (!strcmp(oldNick, (*user_iter)->nick)) {
			ircuser_t *user = *user_iter;
			char opChar = user->display[0];
			userlist.erase(user_iter);
			delete [] user->nick;
			delete [] user->display;
			user->nick = new char[strlen(newNick)+1];
			strcpy(user->nick, newNick);
			if (user->opStatus & ~IRCUSER_NORMAL) {
				user->display = new char[strlen(newNick)+2];
				user->display[0] = opChar;
				strcpy(&user->display[1], newNick);
			}
			else {
				user->display = new char[strlen(newNick)+1];
				strcpy(user->display, newNick);
			}
			InsertUser(user);
			return true;
		}
	}
	return false;
}

/***********************
* CIrcChannelWindow
***********************/

CIrcChannelWindow::CIrcChannelWindow(const char *channel, int cx, int cy, int cw, int ch, bool allowUsers)
: CWindow(channel, cx, cy, cw, ch)
{
	int bufferWidth;

	if (allowUsers) {
		bufferWidth = (cw-15) * 0.75f;
		ctrlUserList = new CIrcUserList(bufferWidth + 10, 5, cw-15-bufferWidth, ch - GUI_TITLEBAR_SIZE - 10);
		AddControl(ctrlUserList);
	}
	else {
		bufferWidth = cw-10;
		ctrlUserList = NULL;
	}

	ctrlBuffer = new CTextBuffer("chanbuf", 5, 5, bufferWidth, ch - GUI_TITLEBAR_SIZE - 10, IRC_CHAN_BUFFER_SIZE);
	AddControl(ctrlBuffer);

	locked = true;
}

CIrcChannelWindow::~CIrcChannelWindow(void)
{
	//delete ctrlBuffer;
	//delete ctrlUserList;
}

/*void CIrcChannelWindow::Display(void)
{
	ctrlBuffer->Display();
	ctrlUserList->Display();
}*/

void CIrcChannelWindow::Resize(int cw, int ch)
{
	CControl::Resize(cw, ch);

	int bufferWidth;

	if (ctrlUserList) {
		bufferWidth = (w - (GUI_SPACING * 3)) * 0.75f;
		ctrlUserList->Resize(w - bufferWidth - (GUI_SPACING * 3), h - GUI_TITLEBAR_SIZE - (GUI_SPACING * 2));
	}
	else bufferWidth = w - (GUI_SPACING * 2);

	ctrlBuffer->Resize(bufferWidth, h - GUI_TITLEBAR_SIZE - (GUI_SPACING * 2));
}

bool CIrcChannelWindow::AddUser(const char *nick, bool announce)
{
	if (ctrlUserList) {
		bool ret = ctrlUserList->AddUser(nick);
		if (ret && announce) {
			char joinMsg[64];
			sprintf(joinMsg, "* %s has joined the channel.", nick);
			AddMessage(joinMsg);
		}
		return true;
	}
	else 
		return false;
}

bool CIrcChannelWindow::RemoveUser(const char *nick, const char *msg)
{
	if (ctrlUserList) {
		bool ret = ctrlUserList->RemoveUser(nick);
		if (ret) {
			char rmvMsg[256];
			if (msg)
				sprintf(rmvMsg, "* %s has left the channel. ( %s )", nick, msg);
			else sprintf(rmvMsg, "* %s has left the channel.", nick);
			AddMessage(rmvMsg);
		}
		return ret;
	}
	else 
		return false;
}

bool CIrcChannelWindow::KickUser(const char *nick, const char *msg, const char *src)
{
	if (ctrlUserList) {
		bool ret = ctrlUserList->RemoveUser(nick);
		if (ret) {
			char rmvMsg[1024];
			if (msg)
				sprintf(rmvMsg, "* %s was kicked from the channel by %s. ( %s )", nick, src, msg);
			else
				sprintf(rmvMsg, "* %s was kicked from the channel by %s.", nick, src);
			AddMessage(rmvMsg);
		}
		return ret;
	}
	else 
		return false;
}

bool CIrcChannelWindow::UserQuit(const char *nick, const char *msg)
{
	if (ctrlUserList) {
		bool ret = ctrlUserList->RemoveUser(nick);
		if (ret) {
			char rmvMsg[256];
			if (msg)
				sprintf(rmvMsg, "* %s has quit IRC. ( %s )", nick, msg);
			else sprintf(rmvMsg, "* %s has quit IRC.", nick);
			AddMessage(rmvMsg);
		}
		return ret;
	}
	else 
		return false;
}


void CIrcChannelWindow::NickChange(const char *oldNick, const char *newNick)
{
	if (ctrlUserList) {
		if (ctrlUserList->NickChange(oldNick, newNick)){
			char buf[MAX_STRING_CHARS];
			sprintf(buf, "* %s is now known as %s", oldNick, newNick);
			AddMessage(buf);
		}
	}
}

void CIrcChannelWindow::ChangeUserMode(const char *opNick, const char *nick, const char *mode)
{
	if (!nick || !*nick || !mode || !*mode || !ctrlUserList)
		return;

	if (!ctrlUserList->ChangeUserMode(nick, mode))
		return;
}

void CIrcChannelWindow::AddMessage(const char *msg)
{
	ctrlBuffer->AddText(msg);
}

void CIrcChannelWindow::SetChannelButton(CIrcChannelButton *button)
{
	ctrlChannelButton = button;
}

/***********************
* CIrcChannelButton
***********************/

CIrcChannelButton::CIrcChannelButton(const char *chanName, int cx, int cy, int cw, int ch, CIrcWindow *ircWindow)
: CButton(chanName, cx, cy, cw, ch, NULL)
{
	channelName = new char[strlen(chanName)+1];
	strcpy(channelName, chanName);

	winIrc = ircWindow;

	char lastColor;
	int numChar = Draw.BreakStringByWidth(channelName, w-10, &lastColor, GUI_FONT, false);

	if (numChar < strlen(channelName)) {
		char tempLabel[128];
		strncpy(tempLabel, channelName, numChar);
		SetLabel(tempLabel);
	}

	newMessages = false;
	activeChannel = false;
}

CIrcChannelButton::~CIrcChannelButton(void)
{
	delete [] channelName;
}	

int CIrcChannelButton::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (INBOUNDS(mx,my)) {
		if (mevent == WM_LBUTTONDOWN) {
			selected = true;
			*mhook = this;
		}
		else if (mevent == WM_LBUTTONUP && selected) {
			if (winIrc)
				winIrc->SetActiveChannel(channelName);
			newMessages = false;
			selected = false;
			*mhook = NULL;
		}
		else {
			selected = false;
			*mhook = NULL;
		}
		return 0;
	}
	return 1;
}

void CIrcChannelButton::Display(void)
{
	if (selected || activeChannel) {
		Draw.RawPic(x, y, h, h, eth32.guiAssets.btnselLeft);
		Draw.RawPic(x + h, y, w-(h+h), h, eth32.guiAssets.btnselCenter);
		Draw.RawPic(x2 - h, y, h, h, eth32.guiAssets.btnselRight);
	}
	else {
		Draw.RawPic(x, y, h, h, eth32.guiAssets.btnLeft);
		Draw.RawPic(x + h, y, w-(h+h), h, eth32.guiAssets.btnCenter);
		Draw.RawPic(x2 - h, y, h, h, eth32.guiAssets.btnRight);
	}

	if (newMessages) {
		vec4_t flashColor;

		VectorCopy(GUI_FONTCOLOR1, flashColor);
		uint32 _time = Time();
		flashColor[3] = sin((_time % IRC_CHAN_FLASH_TIME) * M_PI / IRC_CHAN_FLASH_TIME);
		Draw.TextCenter(x + (w >> 1), y + 2, GUI_FONTSCALE, label, flashColor, qtrue, qfalse, GUI_FONT, true);
	}
	else Draw.TextCenter(x + (w >> 1), y + 2, GUI_FONTSCALE, label, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
}

void CIrcChannelButton::NewMessage(bool newmsg)
{
	newMessages = newmsg;
}

/***********************
* CIrcWindow
***********************/

CIrcWindow::CIrcWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	showTitle = false; 

	ctrlInput = new CTextInput("ircinput",	5, wh-20, ww-10, 15, IRC_MAX_MSG_LEN, funcIrcUserCommand);

	AddControl((CControl*)ctrlInput);

	// set input behavior to keep keybd focus even after enter is pressed
	ctrlInput->KeepFocus(true);

	// don't allow user to move or minimize this window, no reason to allow it
	locked = true;

	activeChannel = NULL;

	channelList.clear();
	channelButtons.clear();

	AddChannel("Status", false);
}

void CIrcWindow::Display(void)
{
	CWindow::Display();

	if (activeChannel) 
		activeChannel->Display();

	if (!channelButtons.empty()) {
		for (list<CIrcChannelButton*>::iterator but_iter = channelButtons.begin() ; but_iter != channelButtons.end() ; but_iter++)
		{
			(*but_iter)->Display();
		}
	}
}

int CIrcWindow::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (INBOUNDS(mx,my)) {
		if (activeChannel) {
			if (activeChannel->ProcessMouse(mx, my, mevent, mhook, khook) == 0) 
				return 0;
		}

		if (!channelButtons.empty()) {
			for (list<CIrcChannelButton*>::iterator but_iter = channelButtons.begin() ; but_iter != channelButtons.end() ; but_iter++) {
				if ((*but_iter)->ProcessMouse(mx, my, mevent, mhook, khook) == 0)
					return 0;
			}
		}

		// mouse was within this window, event handled
		return 0;
	}
	return 1;
}

int CIrcWindow::ProcessKeybd(unsigned char key, CControl **khook)
{
	// tab through available channel windows
	if (key == 0x09) {	// TAB
		if (channelList.size() > 1 && activeChannel) {
			list<CIrcChannelWindow*>::iterator chan_iter = channelList.begin();
			
			while (*chan_iter != activeChannel && chan_iter != channelList.end())
				chan_iter++;

			chan_iter++;

			if (chan_iter == channelList.end())
				chan_iter = channelList.begin();
				
			char buf[64];
			(*chan_iter)->GetLabel(buf,sizeof(buf));
			SetActiveChannel(buf);
			return 0;
		}
		return 0;
	}
	// if not tab, pass the input to the input control
	else if (ctrlInput) {
		ctrlInput->ProcessKeybd(key, khook);
		return 0;
	}

	return 1;
}

void CIrcWindow::SetKeybdFocus(bool set)
{
	CWindow::SetKeybdFocus(set);

	if (ctrlInput)
		ctrlInput->SetKeybdFocus(set);
}

CIrcChannelWindow* CIrcWindow::GetChannelWindowByName(const char *channelName)
{
	if (channelList.empty())
		return NULL;

	char buf[64];
	for (list<CIrcChannelWindow*>::iterator chan_iter = channelList.begin() ; chan_iter != channelList.end() ; chan_iter++)
	{
		(*chan_iter)->GetLabel(buf,sizeof(buf));
		if (!strcmp(channelName, buf))
			return *chan_iter;
	}

	return NULL;
}

bool CIrcWindow::AddChannel(const char *channelName, bool allowUsers)
{
	if (GetChannelWindowByName(channelName) != NULL){ // channel by that name already exists
		return false;
	}

	if (channelList.size() == IRC_MAX_CHANNELS){ // we already have max channels open
		return false;
	}

	int fakeWidth = w / eth32.cg.screenXScale;
	int fakeHeight = h / eth32.cg.screenYScale;

	CIrcChannelWindow *channelWin = new CIrcChannelWindow(channelName, x + 5, y + 5, fakeWidth - 10, fakeHeight - 40, allowUsers);
	CIrcChannelButton *channelBut = new CIrcChannelButton(channelName, x, y, IRC_CHAN_BUTTON_WIDTH, 12, this);

	channelBut->SetOrigin(x, y);

	channelList.push_back(channelWin);
	InsertButton(channelBut);

	channelWin->SetChannelButton(channelBut);

	SetActiveChannel(channelName);

	Reorganize();

	return true;
}

bool CIrcWindow::RemoveChannel(const char *channelName)
{
	if (!strcmp(channelName, "Status"))		// never allowed to remove status window
		return false;

	CIrcChannelWindow *chanWindow = GetChannelWindowByName(channelName);

	if (chanWindow == NULL) // channel doesn't exist
		return false;

	CIrcChannelButton *chanButton = chanWindow->GetChannelButton();

	for (list<CIrcChannelWindow*>::iterator chan_iter = channelList.begin() ; chan_iter != channelList.end() ; chan_iter++)
	{
		if (chanWindow == *chan_iter) {
			delete (chanWindow);
			channelList.erase(chan_iter);
			RemoveButton(chanButton);
			Reorganize();

			if (activeChannel == chanWindow)
				SetActiveChannel("Status");

			return true;
		}
	}
	return false;
}

bool CIrcWindow::RemoveAllChannels(void)
{
	// no channels to remove
	if (channelList.empty())
		return false;

	char buf[64];
	for (list<CIrcChannelWindow*>::iterator chan_iter = channelList.begin() ; chan_iter != channelList.end() ; chan_iter++)
	{
		CIrcChannelWindow *chanWindow = *chan_iter;
		chanWindow->GetLabel(buf,sizeof(buf));
		if (strcmp(buf, "Status"))
		{
			CIrcChannelButton *chanButton = chanWindow->GetChannelButton();
			delete (chanWindow);
			channelList.erase(chan_iter);
			RemoveButton(chanButton);
		}
	}
	SetActiveChannel("Status");
	Reorganize();
	return true;
}


bool CIrcWindow::InsertButton(CIrcChannelButton *btn)
{
	if (channelButtons.empty()) {
		channelButtons.push_front(btn);
		return true;
	}

	list<CIrcChannelButton*>::iterator but_next;

	char btnLbl[64], itrLbl[64], nxtLbl[64];
	for (list<CIrcChannelButton*>::iterator but_iter = channelButtons.begin() ; but_iter != channelButtons.end() ; but_iter++)
	{
		but_next = but_iter;
		but_next++;
		if (but_next != channelButtons.end()) {
			btn->GetLabel(btnLbl,sizeof(btnLbl));
			(*but_iter)->GetLabel(itrLbl, sizeof(itrLbl));
			(*but_next)->GetLabel(nxtLbl,sizeof(nxtLbl));
			if (strcmp(btnLbl, itrLbl) >= 0 && strcmp(btnLbl, nxtLbl) <= 0) {
				channelButtons.insert(but_next, btn);
				return true;
			}
		}
		else {
			channelButtons.push_back(btn);
			return true;
		}
	}
	return false;
}

bool CIrcWindow::RemoveButton(CIrcChannelButton *btn)
{
	if (channelButtons.empty() || btn == NULL)
		return false;

	for (list<CIrcChannelButton*>::iterator but_iter = channelButtons.begin() ; but_iter != channelButtons.end() ; but_iter++)
	{
		if (btn == *but_iter) {
			delete btn;
			channelButtons.erase(but_iter);
			return true;
		}
	}
	return false;
}

bool CIrcWindow::AddUser(const char *nick, const char *channelName, bool announce)
{
	CIrcChannelWindow *chanWindow = GetChannelWindowByName(channelName);

	if (chanWindow == NULL)		// channel not found
		return false;
			
	return chanWindow->AddUser(nick, announce);
}

// used to remove the user from a specific channel
bool CIrcWindow::RemoveUser(const char *nick, const char *channelName, const char *msg)
{
	CIrcChannelWindow *chanWindow = GetChannelWindowByName(channelName);

	if (chanWindow == NULL)		// channel not found
		return false;

	return chanWindow->RemoveUser(nick, msg);
}

// used to remove the user completely (ex: on user QUIT)
void CIrcWindow::UserQuit(const char *nick, const char *msg)
{
	if (!channelList.empty()) {
		for (list<CIrcChannelWindow*>::iterator chan_iter = channelList.begin() ; chan_iter != channelList.end() ; chan_iter++)
		{
			(*chan_iter)->UserQuit(nick, msg);
		}
	}
}

void CIrcWindow::NickChange(const char *oldNick, const char *newNick)
{
	for (list<CIrcChannelWindow*>::iterator chan_iter = channelList.begin() ; chan_iter != channelList.end() ; chan_iter++)
	{
		(*chan_iter)->NickChange(oldNick, newNick);
	}
}

bool CIrcWindow::ChannelMessage(const char *channelName, const char *nick, const char *msg)
{
	CIrcChannelWindow *chanWindow = GetChannelWindowByName(channelName);

	if (chanWindow == NULL)		// channel not found
		return false;

	char ircmsg[1024];
	
	if (nick) {
		sprintf(ircmsg, "^7%s^9: ^2%s", nick, msg);
		chanWindow->AddMessage(ircmsg);
	}
	else {
		chanWindow->AddMessage(msg);
	}

	if (chanWindow != activeChannel)
		chanWindow->GetChannelButton()->NewMessage(true);

	// no need to send all the status messages to chat window
	if (!strcmp(channelName, "Status") || !nick)
		return true;

	sprintf(ircmsg, "^9[^7%s^9] ^7%s^9: ^2%s\n", channelName, nick, msg);

	switch (eth32.settings.ircChatMsgs)
	{
	case IRC_ROUTING_OFF:
		break;
	case IRC_ROUTING_CURRENT:
		if (chanWindow != activeChannel)
			break;
	case IRC_ROUTING_ALL:
		Gui.ChatMessage(ircmsg);
		break;
	}

	switch (eth32.settings.ircConsoleMsgs)
	{
	case IRC_ROUTING_OFF:
		break;
	case IRC_ROUTING_CURRENT:
		if (chanWindow != activeChannel)
			break;
	case IRC_ROUTING_ALL:
		Gui.BufferConsoleMessage(ircmsg);
		break;
	}

	if (eth32.settings.ircMention && strcmp(nick, Irc.nick) && (strstr(msg, nick) || strstr(msg, Portal.GetUsername()))) {
		char msg[1024]; 
		sprintf(msg, "^7%s ^zmentioned you in ^7%s", nick, channelName);
		Gui.CenterPrint(msg, 10);
	}

	return true;
}

bool CIrcWindow::SetActiveChannel(const char *channelName)
{
	CIrcChannelWindow *chanWindow = GetChannelWindowByName(channelName);

	if (chanWindow == NULL)		// channel not found
		return false;

	if (chanWindow == activeChannel)	// channel already active
		return false;

	if (activeChannel)
		activeChannel->GetChannelButton()->SetActiveChannel(false);

	activeChannel = chanWindow;
	chanWindow->GetChannelButton()->SetActiveChannel(true);
	chanWindow->GetChannelButton()->NewMessage(false);
	return true;
}

/*bool CIrcWindow::SetActiveChannel(CIrcChannelWindow *chanWindow)
{
	if (chanWindow == NULL)		// passed us a NULL channel
		return false;

	activeChannel = chanWindow;
	return true;
}*/

void CIrcWindow::Reorganize(void)
{
	int space = 5 * eth32.cg.screenXScale;
	int setX = x + space;
	int setY = y + space;

	int realButtonWidth = IRC_CHAN_BUTTON_WIDTH * (eth32.game.glconfig->vidWidth / 640.f);
	int realButtonHeight = 12 * eth32.cg.screenYScale;

	if (!channelButtons.empty()) {
		for (list<CIrcChannelButton*>::iterator but_iter = channelButtons.begin() ; but_iter != channelButtons.end() ; but_iter++)
		{
			if ((setX + realButtonWidth + space) > w) {
				setX = x + space;
				setY += realButtonHeight + space;
			}
			(*but_iter)->Reposition(setX, setY);
			//(*but_iter)->SetOrigin(x, y);
			setX += realButtonWidth + space;
		}
		setY += realButtonHeight + space;
	}
	int height = h - setY - (12 * eth32.cg.screenYScale) - GUI_SPACING; 
	if (!channelList.empty()) {
		for (list<CIrcChannelWindow*>::iterator chan_iter = channelList.begin() ; chan_iter != channelList.end() ; ++chan_iter)
		{
			(*chan_iter)->Resize(w - (space << 1), height);
			(*chan_iter)->Reposition(x + space, setY);
		}
	}
}	

char* CIrcWindow::GetActiveChannel(char *s, size_t s_s)
{
	if (activeChannel){
		char buf[64];
		activeChannel->GetLabel(buf,sizeof(buf));
		strcpy(s, buf);
	} else
		s[0] = 0;

	return s;
}

// Helper Function
void funcIrcUserCommand(const char *cmd)
{
	Irc.ParseUserInput(cmd);
}// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include <list>

#include "CWindow.h"
#include "CButtons.h"
#include "CTextControls.h"

typedef struct ircuser_s
{
	char *nick;
	char *display;
	unsigned int opStatus;
} ircuser_t;

class CIrcWindow;

class CIrcChannelButton : public CButton
{
public:
	CIrcChannelButton(const char *chanName, int wx, int wy, int ww, int wh, CIrcWindow *ircWindow);
	~CIrcChannelButton(void);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 event, CControl **mhook, CControl **khook);

	void NewMessage(bool newmsg);
	const char *GetChannelName(void) { return channelName; }

	void SetActiveChannel(bool active) { activeChannel = active; }
public:
	CIrcWindow *winIrc;
	char *channelName;
	bool newMessages;
	bool activeChannel;
};

class CIrcUserList : public CControl
{
public:
	CIrcUserList(int cx, int cy, int cw, int ch);
	~CIrcUserList();
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	void Resize(int cw, int ch);
	void Reposition(int cx, int cy);
	void SetOrigin(int ox, int oy);
	bool AddUser(const char *nick);			// return true on success
	bool RemoveUser(const char *nick);		// return true on success

	void FixDisplayNick(ircuser_t *user);
	bool ChangeUserMode(const char *nick, const char *modeStr);

	bool NickChange(const char *oldNick, const char *newNick);
private:
	ircuser_t* CreateIrcUser(const char *nick);
	ircuser_t* GetIrcUser(const char *nick);
	void DestroyIrcUser(ircuser_t *user);
	void InsertUser(ircuser_t *user);
	void RemoveUser(ircuser_t *user);
	bool UserHigher(ircuser_t *thisUser, ircuser_t *otherUser);
	
	int userCount;
	CScrollBar *scrollbar;
	list<ircuser_t*> userlist;
};

class CIrcChannelWindow : public CWindow
{
public:
	CIrcChannelWindow(const char *channel, int cx, int cy, int cw, int ch, bool allowUsers);
	~CIrcChannelWindow(void);
	//void Display(void);
	void Resize(int cw, int ch);

	bool AddUser(const char *nick, bool announce);
	bool RemoveUser(const char *nick, const char *msg);
	bool KickUser(const char *nick, const char *msg, const char *src);
	bool UserQuit(const char *nick, const char *msg);
	void NickChange(const char *oldNick, const char *newNick);
	void ChangeUserMode(const char *opNick, const char *nick, const char *mode);

	void AddMessage(const char *msg);

	void SetChannelButton(CIrcChannelButton *button);
	CIrcChannelButton* GetChannelButton(void) { return ctrlChannelButton; }
	CIrcUserList* GetUserList(void) { return ctrlUserList; }
private:
	// these are created and deleted by the channel window
	CIrcUserList *ctrlUserList;
	CTextBuffer *ctrlBuffer;
	// this is set by main IRC window, and should not be destroyed here
	CIrcChannelButton *ctrlChannelButton;
};

class CIrcWindow : public CWindow
{
public:
	CIrcWindow(char *wlabel, int wx, int wy, int ww, int wh);
	~CIrcWindow(void);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	int ProcessKeybd(unsigned char key, CControl **khook);
	void SetKeybdFocus(bool set);
	bool CaptureEscapeCharacter(void) { return false; }

	void SetProps(const char *props, float xScale, float yScale) {   }

	CIrcChannelWindow* GetChannelWindowByName(const char *channelName);
	
	bool AddChannel(const char *channelName, bool allowUsers = true);
	bool RemoveChannel(const char *channelName);
	bool RemoveAllChannels(void);

	bool AddUser(const char *userName, const char *channelName, bool announce = true);
	bool RemoveUser(const char *userName, const char *channelName, const char *msg = NULL);
	void UserQuit(const char *userName, const char *msg = NULL);

	void NickChange(const char *oldNick, const char *newNick);

	bool ChannelMessage(const char *channelName, const char *nick, const char *msg);

	bool SetActiveChannel(const char *channelName);
	//bool SetActiveChannel(CIrcChannelWindow *chanWindow);
	char* GetActiveChannel(char *s, size_t s_s);
private:
	void Reorganize(void);
	bool InsertButton(CIrcChannelButton *btn);
	bool RemoveButton(CIrcChannelButton *btn);

	CTextInput *ctrlInput;
	
	list<CIrcChannelWindow*> channelList;
	list<CIrcChannelButton*> channelButtons;
	CIrcChannelWindow *activeChannel;
};

// Helper IRC function
void funcIrcUserCommand(const char *cmd);
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CPlayerWindow::CPlayerWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	showTitle = false;
}

void CPlayerWindow::Display(void)
{
	vec4_t teamColor = { eth32.settings.colorTeam[0]/255.f, eth32.settings.colorTeam[1]/255.f, eth32.settings.colorTeam[2]/255.f, 0.6 }; 
	vec4_t enemyColor = { eth32.settings.colorEnemy[0]/255.f, eth32.settings.colorEnemy[1]/255.f, eth32.settings.colorEnemy[2]/255.f, 0.6 }; 
	int team_x = x + 5;
	int team_y = y + 5;
	int enemy_x = x + (w >> 1) + 5;
	int enemy_y = y + 5;

	CWindow::Display();

	for (int i=0 ; i<MAX_CLIENTS ; i++)
	{
		if (IS_INFOVALID(i) && !IS_SPECTATOR(i) && i != eth32.cg.clientNum) {
			if (IS_FRIENDLY(i)) {
				DrawPlayerInfo(i, team_x, team_y, 150, 30, teamColor);
				team_y += 33;
			}
			else {
				DrawPlayerInfo(i, enemy_x, enemy_y, 150, 30, enemyColor);
				enemy_y += 33;
			}
		}
	}
}

void CPlayerWindow::DrawPlayerInfo(int clientNum, int px, int py, int pw, int ph, vec4_t color)
{
	Draw.RawFillRect(px, py, pw, ph, color);

	Draw.Text(px+3, py+3, GUI_FONTSCALE, eth32.cg.players[clientNum].name, colorWhite, qfalse, qfalse, GUI_FONT, true);
}

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"

class CPlayerWindow : public CWindow
{
public:
	CPlayerWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
private:
	void DrawPlayerInfo(int clientNum, int px, int py, int pw, int ph, vec4_t color);
};

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CRadarWindow::CRadarWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, ww) // set width and height to ww to keep it square
{
	showTitle = false;

	numPoints = 0;
	memset(points, 0, sizeof(points));

	cx = x + (w >> 1);
	cy = y + (h >> 1);
}

void CRadarWindow::Display(void)
{
	if (!show) return;

	CWindow::Display();

	vec4_t colorTeam, colorEnemy;
	vec3_t pt, my_ang, pt_ang;
	int px, py;
	float delta_ang;
	
	float distFactor = (cx - x - 5)/eth32.settings.radarRange;

	player_t *player;
	
	Vector4Set(colorTeam, eth32.settings.colorTeam[0]/255.f, eth32.settings.colorTeam[1]/255.f, eth32.settings.colorTeam[2]/255.f, 1);
	Vector4Set(colorEnemy, eth32.settings.colorEnemy[0]/255.f, eth32.settings.colorEnemy[1]/255.f, eth32.settings.colorEnemy[2]/255.f, 1);

	Tools.VectorAngles(eth32.cg.refdef->viewaxis[0], my_ang);

	Draw.RawFillRect(cx-2, cy-2, 5, 5, colorWhite);

	for (int i=0 ; i<numPoints ; i++) 
	{
		player = points[i];
		
		pt[0] = player->orHead.origin[0] - eth32.cg.refdef->vieworg[0];
		pt[1] = player->orHead.origin[1] - eth32.cg.refdef->vieworg[1];

		Tools.VectorAngles(pt, pt_ang);
		delta_ang = pt_ang[YAW] - my_ang[YAW] + 90.f;

		px = cx + cos(delta_ang * M_PI/180.f) * player->distance * distFactor;
		py = cy - sin(delta_ang * M_PI/180.f) * player->distance * distFactor;

		Draw.RawFillRect(px-2, py-2, 5, 5, (player->friendly) ? colorTeam : colorEnemy);
	}
	numPoints = 0;

	if (Gui.InputActive()) {
		char buf[64];
		sprintf(buf, "%i", (int)eth32.settings.radarRange);
		Draw.Text(x+GUI_SPACING, y2-GUI_FONTHEIGHT-GUI_SPACING, GUI_FONTSCALE, "Range", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		Draw.Text(x2-GUI_SPACING-TEXTWIDTH(buf), y2-GUI_FONTHEIGHT-GUI_SPACING, GUI_FONTSCALE, buf, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	}
}

int CRadarWindow::MouseWheel(int mx, int my, int wheel)
{
	if (!show) return 1; // not visible, can't process

	if (INBOUNDS(mx,my)) {
		eth32.settings.radarRange += -wheel * 100.f;

		if (eth32.settings.radarRange > 10000.f)
			eth32.settings.radarRange = 10000.f;
		else if (eth32.settings.radarRange < 100.f)
			eth32.settings.radarRange = 100.f;

		return 0;
	}
	return 1;
}

void CRadarWindow::SetOrigin(int ox, int oy)
{
	CControl::SetOrigin(ox, oy);

	cx = x + (w >> 1);
	cy = y + (h >> 1);
}

void CRadarWindow::Reposition(int ox, int oy)
{
	CWindow::Reposition(ox, oy);

	cx = x + (w >> 1);
	cy = y + (h >> 1);
}

void CRadarWindow::AddPlayer(player_t *player)
{
	if (numPoints < MAX_CLIENTS && player->distance < eth32.settings.radarRange) {
		points[numPoints] = player;
		numPoints++;
	}
}// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"

class CRadarWindow : public CWindow
{
public:
	CRadarWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
	int MouseWheel(int mx, int my, int wheel);

	void SetOrigin(int ox, int oy);
	void Reposition(int ox, int oy);

	void AddPlayer(player_t *player);
private:
	player_t *points[MAX_CLIENTS];
	int numPoints;

	int cx, cy;		// center of window
};

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CRespawnWindow::CRespawnWindow(const char *label, int wx, int wy, int ww, int wh)
: CWindow(label, wx, wy, ww, wh)
{
	showTitle = false;

	fontScale = GUI_FONTSCALE * 2.5;
	Resize(w, Draw.sizeTextHeight(fontScale, GUI_FONT) + 6);
}

void CRespawnWindow::Display(void)
{
	static char buffer[64];
	vec4_t color;
	int div = w / 3;

	if (!eth32.settings.respawnTimers)
		return;

	CWindow::Display();

	Vector4Set(color, eth32.settings.colorTeam[0]/255.f, eth32.settings.colorTeam[1]/255.f, eth32.settings.colorTeam[2]/255.f, 1.0);
	sprintf(buffer, "%i", eth32.cg.spawnTimes[TEAM_FRIEND]);
	Draw.TextCenter(x + div, y+3, fontScale, buffer, color, qtrue, qfalse, GUI_FONT, true);

	Vector4Set(color, eth32.settings.colorEnemy[0]/255.f, eth32.settings.colorEnemy[1]/255.f, eth32.settings.colorEnemy[2]/255.f, 1.0);
	sprintf(buffer, "%i", eth32.cg.spawnTimes[TEAM_ENEMY]);
	Draw.TextCenter(x + div + div, y+3, fontScale, buffer, color, qtrue, qfalse, GUI_FONT, true);
}

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"

class CRespawnWindow : public CWindow
{
public:
	CRespawnWindow(const char *label, int wx, int wy, int ww, int wh);
	void Display(void);
private:
	float fontScale;
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

/********************
* CScrollBar        *
********************/

CScrollBar::CScrollBar(char *clabel, int cx, int cy, int ch, int maxDisplay, int numCurrent, bool topDown)
: CControl(clabel, cx, cy, GUI_SCROLLBAR_WIDTH, ch)
{
	SetMaxDisplayItems(maxDisplay);
	SetNumCurrentItems(numCurrent);

	alignTopDown = topDown;
	currentItemNum = 0;

	Reconfigure();
}

void CScrollBar::Display(void)
{
	if (numCurrentItems <= maxDisplayItems)
		return;

	// buttons and track
	Draw.RawPic(x, y, w, w, eth32.guiAssets.scrollbarArrow);
	Draw.RawPicST(x, yBot, w, w, 0, 1, 1, 0, eth32.guiAssets.scrollbarArrow);

	Draw.RawPic(x, yTop, w, butPosition - yTop, eth32.guiAssets.scrollbarTrack);

	int drawPos = butPosition;
	// scroll button
	if (butSize <= w) { 
		Draw.RawPic(x, butPosition, w, butSize, eth32.guiAssets.scrollbarBtn);
		drawPos = butPosition + butSize;
	} 
	else {
		drawPos = butPosition;
		int drawHeight = (w>>1);
		Draw.RawPicST(x, butPosition, w, drawHeight, 0, 0, 1, 0.5f, eth32.guiAssets.scrollbarBtn);

		drawPos += drawHeight;
		drawHeight = butSize - w;
		Draw.RawPicST(x, drawPos, w, drawHeight, 0, 0.5f, 1, 0.6f, eth32.guiAssets.scrollbarBtn);

		drawPos += drawHeight;
		drawHeight = (w>>1);
		Draw.RawPicST(x, drawPos, w, drawHeight, 0, .5f, 1, 1, eth32.guiAssets.scrollbarBtn);

		drawPos += drawHeight;
	}

	if (drawPos < yBot)
		Draw.RawPic(x, drawPos, w, yBot - drawPos, eth32.guiAssets.scrollbarTrack);
}

int CScrollBar::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (maxDisplayItems >= numCurrentItems)
		return 1;

	if (mevent == WM_LBUTTONDOWN && INBOUNDS(mx,my))
	{
		if (INBOUNDS2(mx, my, x, y, x2, yTop))
		{
			TopButtonPressed();
			Reconfigure();
			return 0;
		}
		if (INBOUNDS2(mx, my, x, yBot, x2, y2))
		{
			BotButtonPressed();
			Reconfigure();
			return 0;
		}

		butPosition = my - (butSize >> 1);
		if (butPosition < yScrollTop)
			butPosition = yScrollTop;
		if (butPosition > yScrollBot)
			butPosition = yScrollBot;

		currentItemNum = GetItemFromPosition();
		*mhook = this;

		return 0;
	}

	if (*mhook == this)
		*mhook = NULL;
	return 1;
}

void CScrollBar::MouseMove(int mx, int my)
{
	butPosition = my - (butSize >> 1);
	if (butPosition < yScrollTop)
		butPosition = yScrollTop;
	if (butPosition > yScrollBot)
		butPosition = yScrollBot;

	currentItemNum = GetItemFromPosition();
}

void CScrollBar::SetOrigin(int ox, int oy)
{
	CControl::SetOrigin(ox, oy);

	yTop = y + w;
	yBot = y2 - w;
	yScrollTop = yTop;
	yScrollBot = yScrollTop + yScrollRange;

	Reconfigure();
}

void CScrollBar::Resize(int cw, int ch)
{
	CControl::Resize(cw, ch);
	Reconfigure();
}

void CScrollBar::SetMaxDisplayItems(int maxDisplay)
{
	if (maxDisplay != maxDisplayItems)
	{
		maxDisplayItems = maxDisplay;
		Reconfigure();
	}
}

void CScrollBar::SetNumCurrentItems(int numCurrent)
{
	if (numCurrent != numCurrentItems)
	{
		numCurrentItems = numCurrent;

		if (currentItemNum > numCurrentItems)
			currentItemNum = numCurrentItems-1;

		if (numCurrentItems <= maxDisplayItems)
			currentItemNum = 0;

		Reconfigure();
	}
}

void CScrollBar::IncCurrentItems(void)
{
	numCurrentItems++;
	Reconfigure();
}

int CScrollBar::GetItemFromPosition(void)
{
	if (alignTopDown)
		return ((butPosition - yScrollTop) / yScrollScale);
	else return ((yScrollBot - butPosition) / yScrollScale);
}

void CScrollBar::DecCurrentItems(void)
{
	if (numCurrentItems > 0)
		numCurrentItems--;
	Reconfigure();
}

void CScrollBar::SetCurrentItemNum(int currentItem)
{
	if (currentItem > (numCurrentItems - maxDisplayItems))
		currentItem = numCurrentItems - maxDisplayItems;
	if (currentItem < 0)
		currentItem = 0;

	currentItemNum = currentItem;
	Reconfigure();
}

void CScrollBar::AdjCurrentItemNum(int amt)
{
	SetCurrentItemNum(currentItemNum + amt);
}

void CScrollBar::TopButtonPressed(void)
{
	if (alignTopDown)
		currentItemNum--;
	else currentItemNum++;

	if (currentItemNum < 0)
		currentItemNum = 0;
	else if (currentItemNum > (numCurrentItems - maxDisplayItems))
		currentItemNum = numCurrentItems - maxDisplayItems;
}

void CScrollBar::BotButtonPressed(void)
{
	if (alignTopDown)
		currentItemNum++;
	else currentItemNum--;

	if (currentItemNum < 0)
		currentItemNum = 0;
	else if (currentItemNum > (numCurrentItems - maxDisplayItems))
		currentItemNum = numCurrentItems - maxDisplayItems;
}

#define IDEAL_PXL_PER_ITEM		2
void CScrollBar::Reconfigure(void)
{
	yTop = y + w;
	yBot = y2 - w;
	yRange = yBot - yTop;

	if (numCurrentItems > maxDisplayItems) {
		numScrollItems = numCurrentItems - maxDisplayItems;

		// we have more pixels than items, yScrollScale should be greater than 1
		if ((yRange - GUI_SCROLL_BTN_MIN) > numScrollItems)  {
			butSize = yRange - (numScrollItems * IDEAL_PXL_PER_ITEM);
			if (butSize < GUI_SCROLL_BTN_MIN) 
				butSize = GUI_SCROLL_BTN_MIN;
		}
		else butSize = GUI_SCROLL_BTN_MIN;

		yScrollRange = yRange - butSize;
		yScrollScale = yScrollRange / (float)numScrollItems;
		yScrollTop = yTop;
		yScrollBot = yScrollTop + yScrollRange;

		if (alignTopDown)
			butPosition = yTop + (currentItemNum * yScrollScale);
		else 
			butPosition = yBot - butSize - (currentItemNum * yScrollScale);


	}
}
		

		

	// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CControl.h"

class CScrollBar : public CControl
{
public:
	CScrollBar(char *label, int cx, int cy, int ch, int maxDisplay, int numCurrent, bool topDown = true);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	void MouseMove(int mx, int my);
	void SetOrigin(int ox, int oy);
	void Resize(int cw, int ch);
	bool IsActive(void) { return numCurrentItems > maxDisplayItems; }

	void SetMaxDisplayItems(int maxDisplay);
	void SetNumCurrentItems(int numCurrent);

	void IncCurrentItems(void);
	void DecCurrentItems(void);

	void SetCurrentItemNum(int currentItem);	// sets currentItemNum to arg
	void AdjCurrentItemNum(int amt);			// adjusts currentItemNum by arg
	int GetCurrentItemNum(void) { return currentItemNum; }
private:
	void Reconfigure(void);

	void TopButtonPressed(void);
	void BotButtonPressed(void);
	int GetItemFromPosition(void);

	int yTop, yBot;					// top & bottom of scrollable region of control
	int yRange;						// range between yTop & yBot

	int yScrollTop, yScrollBot;		// top & bottom of scrollable region from top of scroll button
	float yScrollScale;				// scale of pixels correlating to items per pixel
	int yScrollRange;				// range of pixels between yScrollTop & yScrollBot

	int maxDisplayItems;			// how many items can be displayed at one time
	int numCurrentItems;			// how many items total in list
	int numScrollItems;				// numCurrentItems - maxDisplayItems

	int currentItemNum;				// current start index into item list

	int butSize;					// height of button
	int butPosition;				// current y position of button (from center)

	bool alignTopDown;					// list starts at top or bottom
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

/********************
* CIntSlider        *
********************/

CIntSlider::CIntSlider(char *clabel, int cx, int cy, int cw, int ch, int cmin, int cmax, int *ctarget, const char *ctxt[])
: CControl(clabel, cx, cy, cw, ch)
{
	target = ctarget;
	txtlist = ctxt;
	min = cmin;
	max = cmax;

	btnHeight = GUI_FONTHEIGHT;
	btnWidth = btnHeight * 1.4;
	
	sliderRange = max - min;
	sliderUnit = sliderRange / (float)(w - btnWidth);

	
}

void CIntSlider::Display(void)
{
	if (!target || !show)
		return;

	Refresh();

	char buf[16];
	sprintf(buf, "%i", *target);

	Draw.Text(x, y, GUI_FONTSCALE, label, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);

	if (txtlist)
		Draw.Text(x2 - Draw.sizeTextWidth(GUI_FONTSCALE, txtlist[*target - min], GUI_FONT), y, GUI_FONTSCALE, txtlist[*target - min], GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	else
		Draw.Text(x2 - Draw.sizeTextWidth(GUI_FONTSCALE, buf, GUI_FONT), y, GUI_FONTSCALE, buf, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	// draw track
	Draw.RawPicST(x + (btnWidth >> 1), y2 - btnHeight, btnWidth, btnHeight, 0, 0, 0.25, 1, eth32.guiAssets.sliderTrack);
	Draw.RawPicST(x + btnWidth + (btnWidth >> 1), y2 - btnHeight, w - (btnWidth * 3), btnHeight, 0.25, 0, 0.75, 1, eth32.guiAssets.sliderTrack);
	Draw.RawPicST(x2 - btnWidth - (btnWidth >> 1), y2 - btnHeight, btnWidth, btnHeight, 0.75, 0, 1, 1, eth32.guiAssets.sliderTrack);

	// draw btn
	Draw.RawPic(sliderPos - (btnWidth >> 1), y2 - btnHeight, btnWidth, btnHeight, eth32.guiAssets.sliderBtn);
}

int CIntSlider::ProcessMouse(int mx, int my, uint32 event, CControl **mhook, CControl **khook)
{
	if (!target)
		return 1;

	if (INBOUNDS(mx,my)) {
		if (event == WM_LBUTTONDOWN && INBOUNDS2(mx,my,x,y2-btnHeight,x2,y2)) {	// is mouse in slider region
			*mhook = this;
			*target = min + (int)((mx - x - (btnWidth >> 1)) * sliderUnit + 0.5);	// update our target

			Refresh();

			return 0;
		}
		*mhook = NULL;
		// mouse was in bounds, event handled
		return 0;	
	}
	return 1;
}

void CIntSlider::MouseMove(int mx, int my)
{
	if (mx < x) mx = x;
	if (mx > x2) mx = x2;
	
	*target = min + (int)((mx - x - (btnWidth >> 1)) * sliderUnit + 0.5); // fix for snapping target to right value based on position
	Refresh();

	return;
}

void CIntSlider::SetOrigin(int ox, int oy)
{
	CControl::SetOrigin(ox,oy);
	Refresh();
}

void CIntSlider::Refresh(void)
{
	if (target) {
		if (*target < min) *target = min;
		if (*target > max) *target = max;
		sliderPos = x + (btnWidth >> 1) + (*target - min) / sliderUnit;
	}
}

void CIntSlider::SetTarget(int *ctarget)
{
	target = ctarget;
	Refresh();
}

/********************
* CFloatSlider      *
********************/

CFloatSlider::CFloatSlider(char *clabel, int cx, int cy, int cw, int ch, float cmin, float cmax, float *ctarget)
: CControl(clabel, cx, cy, cw, ch)
{
	target = ctarget;
	min = cmin;
	max = cmax;

	btnHeight = GUI_FONTHEIGHT;
	btnWidth = btnHeight * 1.4;
	
	sliderRange = max - min;
	sliderUnit = sliderRange / (float)(w - btnWidth);

	Refresh();	
}

void CFloatSlider::Display(void)
{
	if (!target || !show)
		return;

	Refresh();

	char buf[16];
	sprintf(buf, "%.3f", *target);

	Draw.Text(x, y, GUI_FONTSCALE, label, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - Draw.sizeTextWidth(GUI_FONTSCALE, buf, GUI_FONT), y, GUI_FONTSCALE, buf, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);

	// draw track
	Draw.RawPicST(x + (btnWidth >> 1), y2 - btnHeight, btnWidth, btnHeight, 0, 0, 0.25, 1, eth32.guiAssets.sliderTrack);
	Draw.RawPicST(x + btnWidth + (btnWidth >> 1), y2 - btnHeight, w - (btnWidth * 3), btnHeight, 0.25, 0, 0.75, 1, eth32.guiAssets.sliderTrack);
	Draw.RawPicST(x2 - btnWidth - (btnWidth >> 1), y2 - btnHeight, btnWidth, btnHeight, 0.75, 0, 1, 1, eth32.guiAssets.sliderTrack);

	// draw btn
	Draw.RawPic(sliderPos - (btnHeight >> 1), y2 - btnHeight, btnWidth, btnHeight, eth32.guiAssets.sliderBtn);
	
	//Draw.RawRect(x, y2, w, 0, colorYellow, 1);
	//Draw.RawRect(sliderPos, y2-4, 0, 5, colorYellow, 1);
}


int CFloatSlider::ProcessMouse(int mx, int my, uint32 event, CControl **mhook, CControl **khook)
{
	if (!target)
		return 1;

	if (INBOUNDS(mx,my)) {
		if (event == WM_LBUTTONDOWN && INBOUNDS2(mx,my,x,y2-btnHeight,x2,y2)) {
			*mhook = this;

			if (mx < (x + (btnWidth >> 1)))
				mx = x + (btnWidth >> 1);
			else if (mx > (x2 - (btnWidth >> 1)))
				mx = x2 - (btnWidth >> 1);

			sliderPos = mx;
			*target = min + (sliderPos - x - (btnWidth >> 1)) * sliderUnit;
			return 0;
		}
		*mhook = NULL;
		return 0;
	}	
	return 1;
}

void CFloatSlider::MouseMove(int mx, int my)
{
	if (mx < (x + (btnWidth >> 1)))
		mx = x + (btnWidth >> 1);
	else if (mx > (x2 - (btnWidth >> 1)))
		mx = x2 - (btnWidth >> 1);

	sliderPos = mx;
	*target = min + (sliderPos - x - (btnWidth >> 1)) * sliderUnit;
	return;
}

void CFloatSlider::SetOrigin(int ox, int oy)
{
	CControl::SetOrigin(ox,oy);
	Refresh();
}

void CFloatSlider::Refresh(void)
{
	if (target) {
		if (*target < min) *target = min;
		if (*target > max) *target = max;
		sliderPos = x + (btnWidth >> 1) + (*target - min) / sliderUnit;
	}
}

void CFloatSlider::SetTarget(float *ctarget)
{
	target = ctarget;
	Refresh();
}

/********************
* CDropbox          *
********************/

CDropbox::CDropbox(char *clabel, int cx, int cy, int cw, int ch, int cmin, int cmax, int *ctarget, const char *ctxt[])
: CControl(clabel, cx, cy, cw, ch)
{
	target = ctarget;
	min = cmin;
	max = cmax;
	txtlist = ctxt;
	
	if (target) {
		if (*target < min)
			*target = min;
		if (*target > max)
			*target = max;
	}

	pointTarget = -1;

	lyOffset = GUI_FONTHEIGHT + 3;
	ly = y + lyOffset;

	lxOffset = (w - (GUI_FONTHEIGHT + 6)) >> 1;
	lx = x + lxOffset;
}

void CDropbox::Display(void)
{
	if (!target)
		return;

	Draw.Text(x, y, GUI_FONTSCALE, label, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);

	lyOffset = GUI_FONTHEIGHT + 3;
	ly = y + lyOffset;

	lxOffset = (w - (GUI_FONTHEIGHT + 6)) >> 1;
	lx = x + lxOffset;

	int drawY = ly;

	char buf[16];

	if (selected) {
		int height = (GUI_FONTHEIGHT + GUI_TEXTSPACING) * (max - min + 1) + GUI_TEXTSPACING;

		if (height > GUI_TITLEBAR_SIZE*2) {
			/*Draw.RawPic(x, ly, GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE, eth32.guiAssets.winTopLeft);
			Draw.RawPic(x+GUI_TITLEBAR_SIZE, ly, w-(GUI_TITLEBAR_SIZE * 2), GUI_TITLEBAR_SIZE, eth32.guiAssets.winTop);
			Draw.RawPicST(x2-GUI_TITLEBAR_SIZE, ly, GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE, 1.f, 0.f, 0.f, 1.f, eth32.guiAssets.winTopLeft);
		
			Draw.RawPic(x, ly+GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE, height-(GUI_TITLEBAR_SIZE*2), eth32.guiAssets.winLeft);
			Draw.RawPic(x+GUI_TITLEBAR_SIZE, ly+GUI_TITLEBAR_SIZE, w-(GUI_TITLEBAR_SIZE*2), height-(GUI_TITLEBAR_SIZE*2), eth32.guiAssets.winCenter);
			Draw.RawPicST(x2-GUI_TITLEBAR_SIZE, ly+GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE, height-(GUI_TITLEBAR_SIZE*2), 1.f, 0.f, 0.f, 1.f, eth32.guiAssets.winLeft);

			Draw.RawPicST(x, ly+height-GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE, 0.f, 1.f, 1.f, 0.f, eth32.guiAssets.winTopLeft);
			Draw.RawPicST(x+GUI_TITLEBAR_SIZE, ly+height-GUI_TITLEBAR_SIZE, w-(GUI_TITLEBAR_SIZE*2), GUI_TITLEBAR_SIZE, 0.f, 1.f, 1.f, 0.f, eth32.guiAssets.winTop);
			Draw.RawPicST(x2-GUI_TITLEBAR_SIZE, ly+height-GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE, 1.f, 1.f, 0.f, 0.f, eth32.guiAssets.winTopLeft);*/
			Draw.RawPicST(x, drawY, GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE >> 1, 0.f, 0.f, 1.f, 0.5f, eth32.guiAssets.txtinputLeft);
			Draw.RawPicST(x+GUI_TITLEBAR_SIZE, drawY, w-(GUI_TITLEBAR_SIZE * 2), GUI_TITLEBAR_SIZE >> 1, 0.f, 0.f, 1.f, 0.5f, eth32.guiAssets.txtinputCenter);
			Draw.RawPicST(x2-GUI_TITLEBAR_SIZE, drawY, GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE >> 1, 0.f, 0.f, 1.f, 0.5f, eth32.guiAssets.txtinputRight);
			drawY += GUI_TITLEBAR_SIZE >> 1;
		
			Draw.RawPicST(x, drawY, GUI_TITLEBAR_SIZE, height-GUI_TITLEBAR_SIZE, 0.f, 0.25f, 1.f, 0.75f, eth32.guiAssets.txtinputLeft);
			Draw.RawPicST(x+GUI_TITLEBAR_SIZE, drawY, w-(GUI_TITLEBAR_SIZE*2), height-GUI_TITLEBAR_SIZE, 0.f, 0.25f, 1.f, 0.75f, eth32.guiAssets.txtinputCenter);
			Draw.RawPicST(x2-GUI_TITLEBAR_SIZE, drawY, GUI_TITLEBAR_SIZE, height-GUI_TITLEBAR_SIZE, 0.f, 0.25f, 1.f, 0.75f, eth32.guiAssets.txtinputRight);
			drawY = ly + height - (GUI_TITLEBAR_SIZE >> 1);

			Draw.RawPicST(x, drawY, GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE >> 1, 0.f, 0.5f, 1.f, 1.f, eth32.guiAssets.txtinputLeft);
			Draw.RawPicST(x+GUI_TITLEBAR_SIZE, drawY, w-(GUI_TITLEBAR_SIZE*2), GUI_TITLEBAR_SIZE >> 1, 0.f, 0.5f, 1.f, 1.f, eth32.guiAssets.txtinputCenter);
			Draw.RawPicST(x2-GUI_TITLEBAR_SIZE, drawY, GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE >> 1, 0.f, 0.5f, 1.f, 1.f, eth32.guiAssets.txtinputRight);
		}
		else {
			int size = height >> 1;
			Draw.RawPicST(x, ly, size, size, 0.f, 0.f, 0.5f, 0.5f, eth32.guiAssets.txtinputLeft);
			Draw.RawPicST(x+size, ly, w-(size*2), size, 0.f, 0.f, 1.f, 0.5f, eth32.guiAssets.txtinputCenter);
			Draw.RawPicST(x2-size, ly, size, size, 0.5f, 0.f, 1.f, 0.5f, eth32.guiAssets.txtinputRight);

			Draw.RawPicST(x, ly+size, size, size, 0.f, 0.5f, 0.5f, 1.f, eth32.guiAssets.txtinputLeft);
			Draw.RawPicST(x+size, ly+size, w-(size*2), size, 0.f, 0.5f, 1.f, 1.f, eth32.guiAssets.txtinputCenter);
			Draw.RawPicST(x2-size, ly+size, size, size, 0.5f, 0.5f, 1.f, 1.f, eth32.guiAssets.txtinputRight);
		}

		height = ly + GUI_TEXTSPACING;
		for (int i=min  ; i<max+1 ; i++) 
		{
			sprintf(buf, "%i",i);
			Draw.TextCenter(x+(w>>1), height, GUI_FONTSCALE, txtlist && txtlist[i-min] ? txtlist[i-min] : buf, pointTarget == i ? GUI_FONTCOLOR2 : GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
			height += GUI_FONTHEIGHT + GUI_TEXTSPACING;
		}
	}
	else {
		Draw.RawPic(x, ly, GUI_FONTHEIGHT + 6, GUI_FONTHEIGHT + 6, eth32.guiAssets.txtinputLeft);
		Draw.RawPic(x + GUI_FONTHEIGHT + 6, ly, w - (GUI_FONTHEIGHT + GUI_FONTHEIGHT + 12), GUI_FONTHEIGHT + 6, eth32.guiAssets.txtinputCenter);
		Draw.RawPic(x2 - (GUI_FONTHEIGHT + 6), ly, GUI_FONTHEIGHT + 6, GUI_FONTHEIGHT + 6, eth32.guiAssets.dropboxArrow);
		
		sprintf(buf, "%i",*target);
		Draw.TextCenter(lx, ly + 3, GUI_FONTSCALE, txtlist && txtlist[*target-min] ? txtlist[*target-min] : buf, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	}
}

int CDropbox::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (!target)
		return 1;

	if (selected) {
		if (mevent == WM_LBUTTONUP && INBOUNDS2(mx, my, x, ly, x2, ly + (GUI_FONTHEIGHT + GUI_TEXTSPACING) * (max - min + 1) + GUI_TEXTSPACING)) {
			*target = min + (my - ly) / (GUI_FONTHEIGHT + GUI_TEXTSPACING);
		}
		*mhook = NULL;
		selected = false;
		pointTarget = -1;
		return 0;
	}	
	if (mevent == WM_LBUTTONDOWN && INBOUNDS2(mx, my, x, ly, x2, ly+GUI_FONTHEIGHT+6)) {
		*mhook = this;
		selected = true;
		pointTarget = min;
		return 0;
	}
	return 1;
}

int CDropbox::MouseWheel(int mx, int my, int wheel)
{
	if (!target)
		return 1;

	if (INBOUNDS(mx,my)) {
		*target -= wheel;

		if (*target < min) 
			*target = min;
		else if (*target > max)
			*target = max;

		return 0;
	}
	return 1;
}

void CDropbox::MouseMove(int mx, int my)
{
	if (selected) {
		if (INBOUNDS2(mx, my, x, ly, x2, ly + (GUI_FONTHEIGHT + GUI_TEXTSPACING) * (max - min + 1) + GUI_TEXTSPACING))
			pointTarget = min + (my - ly) / (GUI_FONTHEIGHT + GUI_TEXTSPACING);
	}
}

void CDropbox::SetTarget(int *ctarget)
{
	target = ctarget;

	if (target) {
		if (*target < min)
			*target = min;
		if (*target > max)
			*target = max;
	}
}

void CDropbox::SetMin(int newMin)
{
	min = newMin;
	
	if (*target < min)
		*target = min;
}

void CDropbox::SetMax(int newMax)
{
	max = newMax;

	if (*target > max)
		*target = max;
}// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CControl.h"

class CIntSlider : public CControl
{
private:
	int *target;
	const char **txtlist;
	int max, min;
	int sliderPos;
	int sliderRange;
	float sliderUnit;
	int btnHeight;
	int btnWidth;
public:
	CIntSlider(char *clabel, int cx, int cy, int cw, int ch, int cmin, int cmax, int *ctarget, const char *ctxt[] = NULL);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	void MouseMove(int mx, int my);
	void SetOrigin(int ox, int oy);
	void Refresh(void);
	void SetTarget(int *ctarget);
};

class CFloatSlider : public CControl
{
protected:
	float *target;
	float max, min;
	int sliderPos;
	float sliderRange;
	float sliderUnit;
	int btnHeight;
	int btnWidth;
public:
	CFloatSlider(char *clabel, int cx, int cy, int cw, int ch, float cmin, float cmax, float *ctarget);
	virtual void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	void MouseMove(int mx, int my);
	virtual void SetOrigin(int ox, int oy);
	virtual void Refresh(void);
	void SetTarget(float *ctarget);
};

// Using text like a intslider can, but more intuitive
class CDropbox : public CControl
{
public:
	CDropbox(char *clabel, int cx, int cy, int cw, int ch, int cmin, int cmax, int *ctarget, const char *ctxt[] = NULL);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	int MouseWheel(int mx, int my, int wheel);
	void MouseMove(int mx, int my);
	void SetTarget(int *ctarget);
	void SetText(const char **ctxt) { txtlist = ctxt; }
	void SetMin(int newMin);
	void SetMax(int newMax);
private:
	int *target;
	void (*func)(int);
	int pointTarget;
	int min, max;
	const char **txtlist;
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CSpecWindow::CSpecWindow(char *wlabel, int wx, int wy, int ww, int wh)
	: CWindow(wlabel, wx, wy, ww, wh)
{
	showTitle = true;
}

void CSpecWindow::Display(void)
{
	if (!Gui.InputActive())
		if ((!eth32.settings.getSpeclist || !eth32.cg.spectators[0][0]))
			return;

	int i, cnt, yPos = y + 22;
	char name[128];

	if (!Gui.InputActive() || eth32.cg.spectators[0][0]) {
		for (i=0; i<MAX_CLIENTS; i++) {
			if (!eth32.cg.spectators[i][0])
				break;

			memset(name, 0, sizeof(name));
			cnt = Draw.BreakStringByWidth(eth32.cg.spectators[i], w-10, NULL, GUI_FONT, false);
			if (cnt > 0 && cnt < sizeof(name))
				strncpy(name, eth32.cg.spectators[i], cnt);
			else
				continue;

			Draw.Text(x + 5, yPos, GUI_FONTSCALE, name, GUI_FONTCOLOR2, qfalse, qfalse, GUI_FONT, true);
			yPos += GUI_FONTHEIGHT + GUI_TEXTSPACING;
		}
	} else {
		Draw.Text(x + 5, yPos, GUI_FONTSCALE, "Spectator 1", GUI_FONTCOLOR2, qfalse, qfalse, GUI_FONT, true);
		yPos += GUI_FONTHEIGHT + GUI_TEXTSPACING;

		Draw.Text(x + 5, yPos, GUI_FONTSCALE, "Spectator 2", GUI_FONTCOLOR2, qfalse, qfalse, GUI_FONT, true);
		yPos += GUI_FONTHEIGHT + GUI_TEXTSPACING;

		i = 2;
	}

	Resize(w, (GUI_FONTHEIGHT * (i+1)) + (GUI_TEXTSPACING * i) + 15);

	CWindow::Display();
}
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"

class CSpecWindow : public CWindow
{
	public:
		CSpecWindow(char *wlabel, int wx, int wy, int ww, int wh);
		void Display(void);
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CStatsWindow::CStatsWindow(const char *label, int wx, int wy, int ww, int wh)
: CWindow(label, wx, wy, ww, wh)
{
	showTitle = true;
	Resize(w, (GUI_FONTHEIGHT * 4) + (GUI_TEXTSPACING * 3) + 10);
}

void CStatsWindow::Display(void)
{
	if (!eth32.settings.showStats)
		return;

	static char buffer[64];
	int yPos = y + 5;

	CWindow::Display();

	sprintf(buffer, "%.2f", 0.001*(float)eth32.cg.snap->ps.grenadeTimeLeft);
	Draw.Text(x + 5, yPos, GUI_FONTSCALE, "Time Remaining:", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - 5 - TEXTWIDTH(buffer), yPos, GUI_FONTSCALE, buffer, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	yPos += GUI_FONTHEIGHT + GUI_TEXTSPACING;

	if (Aimbot.grenadeTarget)
		strncpy(buffer, Aimbot.grenadeTarget->name, Draw.BreakStringByWidth(Aimbot.grenadeTarget->name, w - 15 - TEXTWIDTH("Target:"), NULL, GUI_FONT, false));
	else
		strcpy(buffer, "<none>");

	Draw.Text(x + 5, yPos, GUI_FONTSCALE, "Target:", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - 5 - TEXTWIDTH(buffer), yPos, GUI_FONTSCALE, buffer, GUI_FONTCOLOR2, qfalse, qfalse, GUI_FONT, true);
	yPos += GUI_FONTHEIGHT + GUI_TEXTSPACING;

	sprintf(buffer, "%i", Aimbot.grenadeTarget ? (int)Aimbot.grenadeTarget->distance : -1);
	Draw.Text(x + 5, yPos, GUI_FONTSCALE, "Distance:", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - 5 - TEXTWIDTH(buffer), yPos, GUI_FONTSCALE, buffer, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	yPos += GUI_FONTHEIGHT + GUI_TEXTSPACING;

	sprintf(buffer, "%.1f s", Aimbot.grenadeTarget ? Aimbot.rifleGrenadeTime : 0.0);
	Draw.Text(x + 5, yPos, GUI_FONTSCALE, "Flytime:", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2 - 5 - TEXTWIDTH(buffer), yPos, GUI_FONTSCALE, buffer, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
}

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"

class CStatsWindow : public CWindow
{
public:
	CStatsWindow(const char *label, int wx, int wy, int ww, int wh);
	void Display(void);
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CStatusWindow::CStatusWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	showTitle = false;
	statbarSize = 6 * eth32.cg.screenYScale;
}

void CStatusWindow::Display(void)
{
	if (!IS_INFOVALID(eth32.cg.snap->ps.clientNum))
		return;

	CWindow::Display();

	int maxHealth = eth32.cg.snap->ps.stats[STAT_MAX_HEALTH];
	int curHealth = eth32.cg.snap->ps.stats[STAT_HEALTH];

	if (eth32.cgMod->type != MOD_TCE && *eth32.cg.players[eth32.cg.snap->ps.clientNum].cls == PC_MEDIC)
		maxHealth *= 1.12;

	if (curHealth < 0)
		curHealth = 0;

	float healthFrac = curHealth / (float)maxHealth;
	char buffer[16];
	sprintf(buffer, "%i", curHealth);
	
	int drawX = x + GUI_SPACING;
	int drawY = y + GUI_SPACING;

	Draw.Text(drawX, drawY, GUI_FONTSCALE, "Health", eth32.guiAssets.textColor1, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(x2-GUI_SPACING-Draw.sizeTextWidth(GUI_FONTSCALE, buffer, GUI_FONT), drawY, GUI_FONTSCALE, buffer, eth32.guiAssets.textColor2, qtrue, qfalse, GUI_FONT, true);
	drawY += GUI_FONTHEIGHT + GUI_SPACING;
	vec4_t healthColor;
	Draw.ColorForHealth(curHealth, healthColor);
	Draw.Statbar(drawX, drawY, w-GUI_SPACING-GUI_SPACING, statbarSize, healthFrac, healthColor);
	
	drawY += statbarSize + GUI_SPACING;

	if (eth32.cg.pmext) {
		float stamFrac = eth32.cg.pmext->sprintTime / (float)SPRINTTIME;
		sprintf(buffer, "%i", (int)(stamFrac * 100.f));

		Draw.Text(drawX, drawY, GUI_FONTSCALE, "Stamina", eth32.guiAssets.textColor1, qtrue, qfalse, GUI_FONT, true);
		Draw.Text(x2-GUI_SPACING-Draw.sizeTextWidth(GUI_FONTSCALE, buffer, GUI_FONT), drawY, GUI_FONTSCALE, buffer, eth32.guiAssets.textColor2, qtrue, qfalse, GUI_FONT, true);
		
		drawY += GUI_FONTHEIGHT + GUI_SPACING;

		// Add white flash for adrenaline time.
		float msec = eth32.cg.snap->ps.powerups[PW_ADRENALINE] - eth32.cg.time;
		vec4_t color =	{0, 0, 1, 1};
		
		if( msec < 0 ) 
			msec = 0;
		else 
			Vector4Average( color, colorWhite, .5f + sin(.2f * sqrt(msec) * 2 * M_PI) * .5f, color);

		Draw.Statbar(drawX, drawY, w-GUI_SPACING-GUI_SPACING, statbarSize, stamFrac, color);
	}
}


// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"

class CStatusWindow : public CWindow
{
public:
	CStatusWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
private:
	int statbarSize;
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

/********************
* CTextBuffer       *
********************/

CTextBuffer::CTextBuffer(char *clabel, int cx, int cy, int cw, int ch, int bufferSize)
: CControl(clabel, cx, cy, cw, ch)
{
	maxBuffer = bufferSize;
	inputLineCount = dispLineCount = 0;
	startLine = 0;
	inputHead = inputTail = NULL;
	dispHead = dispTail = dispCurrent = NULL;
	fontHeight = Draw.sizeTextHeight(GUI_FONTSCALE, GUI_FONT);
	currentId = 0;
	breakWidth = w - (GUI_SCROLLBAR_WIDTH * eth32.cg.screenXScale) - GUI_SPACING;

	scrollbar = new CScrollBar("bufscroll", cw - GUI_SCROLLBAR_WIDTH, 0, ch, GUI_SCROLLBAR_WIDTH, 0, false);
	scrollbar->SetOrigin(x, y);

	scrollbar->SetMaxDisplayItems(h / (GUI_FONTHEIGHT + GUI_TEXTSPACING));
}

CTextBuffer::~CTextBuffer(void)
{
	delete scrollbar;

	ClearBuffer();
}

void CTextBuffer::ClearBuffer(void)
{
	bufline_t *temp = inputHead;
	while (temp) 
	{
		inputHead = temp->next;
		delete [] temp->text;
		delete temp;
		temp = inputHead;
	}
	
	inputLineCount = dispLineCount = 0;
	inputHead = inputTail = NULL;
	dispHead = dispTail = dispCurrent = NULL;

	scrollbar->SetNumCurrentItems(0);
}


void CTextBuffer::Display(void)
{
	int textY = y2 - (GUI_FONTHEIGHT + GUI_TEXTSPACING);

	bufline_t *bufferLine = dispCurrent;

	int curPos = 0;
	int startPos = startLine = scrollbar->GetCurrentItemNum();
	
	while (curPos < startPos && bufferLine)
	{
		bufferLine = bufferLine->next;
		curPos++;
	}

	while (bufferLine && textY > y) 
	{
		if (bufferLine->text)
			Draw.Text(x, textY, GUI_FONTSCALE, bufferLine->text, colorWhite, qfalse, qfalse, GUI_FONT, true);
#ifdef ETH32_DEBUG
		else 
			Debug.Log("ERROR: CTextBuffer::Display() - encountered NULL buffer line text");
#endif
		bufferLine = bufferLine->next;
		textY -= GUI_TEXTSPACING + GUI_FONTHEIGHT;
	}

	if (Gui.InputActive())
		scrollbar->Display();
}

int CTextBuffer::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	return scrollbar->ProcessMouse(mx, my, mevent, mhook, khook);
}

int CTextBuffer::MouseWheel(int mx, int my, int wheel)
{
	if (INBOUNDS(mx,my)) {
		scrollbar->AdjCurrentItemNum(wheel);
		return 0;
	}
	return 1;
}

void CTextBuffer::SetOrigin(int ox, int oy)
{
	CControl::SetOrigin(ox, oy);
	scrollbar->SetOrigin(x, y);
}

void CTextBuffer::Resize(int cw, int ch)
{
	CControl::Resize(cw, ch);
	scrollbar->Reposition(w - GUI_SPACING - (GUI_SCROLLBAR_WIDTH * eth32.cg.screenXScale), 0);
	scrollbar->Resize(GUI_SCROLLBAR_WIDTH * eth32.cg.screenXScale, h);
	scrollbar->SetMaxDisplayItems(h / (GUI_FONTHEIGHT + GUI_TEXTSPACING));

	breakWidth = w - (GUI_SCROLLBAR_WIDTH * eth32.cg.screenXScale) - GUI_SPACING;
}

void CTextBuffer::AddText(const char *text)
{
	if (!text || !(*text)) return;

	int len = strlen(text);
	char *str = new char[len+1];
	char lastColor = -1;
	char newColor = -1;
	
	strcpy(str, text);

	char *p = &str[len-1]; // get rid of newline char that q3 adds to a lot of msgs
	if (*p == '\n') 
		*p = '\0';

	p = str;
	
	int count = Draw.BreakStringByWidth(p, breakWidth, &lastColor, GUI_FONT, true);
	while (count)
	{
		bufline_t *addLine = new bufline_t;
		 
		if (newColor >= 0) {	// concat string after previous color code
			addLine->text = new char[count+3];
			sprintf(addLine->text, "^%c", newColor);
			strncat(addLine->text, p, count);
			addLine->text[count+2] = '\0';
		}
		else {					// no need for color, cpy it straight in
			addLine->text = new char[count+1];
			strncpy(addLine->text, p, count);
			addLine->text[count] = '\0';
		}

		addLine->prev = NULL;
		addLine->next = dispHead;
		if (dispHead) {
			dispHead->prev = addLine;
			dispHead = addLine;
			dispCurrent = dispCurrent->prev;
		} 
		else {
			dispHead = dispTail = addLine;
			dispCurrent = dispHead;
		}
		dispLineCount++;

		if (startLine)
			startLine++;

		p += count;
		newColor = lastColor;
		count = Draw.BreakStringByWidth(p, breakWidth, &lastColor, GUI_FONT, true);
	}
	// trim down our list to [maxBuffer] lines
	while (dispLineCount > maxBuffer) {
		bufline_t *del = dispTail;
		dispTail = dispTail->prev;
		dispTail->next = NULL;
		delete [] del->text;
		delete del;
		dispLineCount--;
	}
	scrollbar->SetNumCurrentItems(dispLineCount);
	scrollbar->SetCurrentItemNum(startLine);
}

const char* CTextBuffer::GetTextClick(int mx, int my)
{
	if (INBOUNDS(mx,my)) {
		// TODO: will eventually need to make sure this wasn't on buffer slider	
		int linenum = (y2 - my) / (GUI_FONTHEIGHT + GUI_TEXTSPACING);
		float xpos = mx - x;
		
		fontInfo_t *font = GUI_FONT;
		bufline_t *line = dispHead;
		int cnt = 0;
		float charpos = 0.0;

		if (scrollbar->IsActive()) {
			int startLine = scrollbar->GetCurrentItemNum();
			while (startLine > 0) {
				line = line->next;
				startLine--;
			}
		}

		while (line && cnt < linenum) {
			line = line->next;
			cnt++;
		}

		if (line) {
			const char *p = line->text;
			
			while (p && *p && charpos < xpos) {
				if (Q_IsColorString(p)) {
					p += 2;
					continue;
				}
				charpos += font->glyphs[(unsigned char)*p].xSkip * font->glyphScale * GUI_FONTSCALE;
				p++;
			}
		
			if (charpos > xpos)
				p--;

			while (p != line->text && *(p-1) != ' ')
				p--;

			return p;
		}
	}
	return NULL;
}

/********************
* CTextInput        *
********************/

CTextInput::CTextInput(char *clabel, int cx, int cy, int cw, int ch, int maxLen, void (*cfunc)(const char *))
: CControl(clabel, cx, cy, cw, ch)
{
	func = cfunc;
	maxLength = maxLen;
	buffer = new char[maxLength];
	memset(buffer, 0, sizeof(buffer));
	bufferCount = 0;
	inputPos = drawPos = buffer;
	cursorTime = 0;
	lastColor = -1;
	keepFocus = false;
}

CTextInput::~CTextInput(void)
{
	delete [] buffer;
}

void CTextInput::Display(void)
{
	if (!show)
		return;

	float *color = (lastColor > -1) ? g_color_table[ColorIndex(lastColor)] : GUI_FONTCOLOR1;

	Draw.RawPic(x, y, h, h, eth32.guiAssets.txtinputLeft);
	Draw.RawPic(x + h, y, w - (h+h), h, eth32.guiAssets.txtinputCenter);
	Draw.RawPic(x2 - h, y, h, h, eth32.guiAssets.txtinputRight);

	Draw.Text(x+5, y+4, GUI_FONTSCALE, drawPos, color, qfalse, qfalse, GUI_FONT, true);

	if (selected)
		DrawCursor();
}

int CTextInput::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (!show)
		return 1;

	if (INBOUNDS(mx,my) && mevent == WM_LBUTTONDOWN) {
		selected = true;
		*khook = this;
		return 0;
	}
	return 1;
}

int CTextInput::ProcessKeybd(unsigned char key, CControl **khook)
{
	switch (key)
	{
	case 0x1B:		// escape
		ClearInput();
		*khook = NULL;
		break;
	case 0x08:		// backspace
		if (bufferCount) {
			bufferCount--;
			buffer[bufferCount] = 0;
			SetDrawPosition();
		}
		break;
	case 0x0D:		// enter
		if (buffer[0] && func)
			func(buffer);
		ClearInput();
		if (!keepFocus)
			*khook = NULL;
		else SetFocus();
		break;
	default:
		if (bufferCount < maxLength - 1) {
			buffer[bufferCount] = key;
			bufferCount++;
			buffer[bufferCount] = 0;
			SetDrawPosition();
		}
	}
	return 0;
}

void CTextInput::SetFocus(void)
{
	selected = true;
}

void CTextInput::SetKeybdFocus(bool set)
{
	if (set && !selected) {
		selected = true;
		return;
	}
	if (!set && selected) {
		ClearInput();
		return;
	}
}

void CTextInput::KeepFocus(bool keep)
{
	keepFocus = keep;
}

void CTextInput::ClearInput(void)
{
	buffer[0] = 0;
	bufferCount = 0;
	inputPos = drawPos = buffer;
	selected = false;
	lastColor = -1;
}

void CTextInput::DrawCursor(void)
{
	static bool show = true;
	
	uint32 _time = Time();

	if (_time - cursorTime > GUI_CURFLASHTIME) {
		show = !show;
		cursorTime = _time;
	}

	if (show)
		Draw.Text(x + 5 + Draw.sizeTextWidth(GUI_FONTSCALE, drawPos, GUI_FONT), y + 2, GUI_FONTSCALE, "|", GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
}

void CTextInput::SetDrawPosition(void)
{
	char *p = buffer;
	int width = Draw.sizeTextWidth(GUI_FONTSCALE, p, GUI_FONT);

	while (width > w - 10)	// 10 for the padding of 5 on each side
	{
		if (Q_IsColorString(p))
			lastColor = *(p+1);
		p++;
		width = Draw.sizeTextWidth(GUI_FONTSCALE, p, GUI_FONT);
	}

	drawPos = p;
}// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CControl.h"
#include "CScrollBar.h"

typedef struct bufline_s
{
	qhandle_t shader;
	char *text;

	uint32 id;

	bufline_s *next, *prev;
} bufline_t;

class CTextBuffer : public CControl
{
public:
	CTextBuffer(char *clabel, int cx, int cy, int cw, int ch, int bufferSize);
	~CTextBuffer(void);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	int MouseWheel(int mx, int my, int wheel);
	void SetOrigin(int ox, int oy);
	void Resize(int cw, int ch);

	void AddText(const char *text);

	void ClearBuffer(void);

	const char *GetTextClick(int mx, int my);
private:
	int maxBuffer;
	int fontHeight;
	int inputLineCount, dispLineCount;
	int startLine;

	int breakWidth;

	uint32 currentId;

	CScrollBar *scrollbar;

	bufline_t *inputHead, *inputTail;
	bufline_t *dispHead, *dispTail, *dispCurrent;
};

class CTextInput : public CControl
{
public:
	CTextInput(char *clabel, int cx, int cy, int cw, int ch, int maxLen, void (*cfunc)(const char*));
	~CTextInput(void);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	int ProcessKeybd(unsigned char key, CControl **khook);
	void SetFocus(void);
	void SetKeybdFocus(bool set);
	void KeepFocus(bool keep);
	bool CaptureEscapeCharacter(void) { return !keepFocus; }
private:
	void ClearInput(void);
	void DrawCursor(void);
	void SetDrawPosition(void);

	void (*func)(const char*);
	char *buffer;
	int maxLength;
	int bufferCount;
	char *drawPos;
	char *inputPos;
	uint32 cursorTime;
	int lastColor;

	bool keepFocus;
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

// helper funcs

void funcJoinPortalUser(void)
{
	for (int i=0; i<Portal.numUsers ; i++)
	{
		if (!strcmp(eth32.cg.selectedPortalUser, Portal.users[i].username)) {
			char buf[42];
			sprintf(buf, "connect %s", Portal.users[i].server);
			Gui.BufferConsoleCommand(buf);
			Gui.SetView(GUI_MAINVIEW);
			//Syscall.CG_SendConsoleCommand(va("connect %s", Portal.users[i].server));
			return;
		}
	}
}

void funcAddPortalFriend(void)
{
	Portal.AddFriend(eth32.cg.selectedPortalUser);
}

void funcRemPortalFriend(void)
{
	Portal.RemoveFriend(eth32.cg.selectedPortalUser);
}

/*********************
* CUsersWindow
*********************/

#define USER_HEIGHT		(GUI_FONTHEIGHT + GUI_FONTHEIGHT + 15)
#define USER_SPACING	((int)(4 * eth32.cg.screenYScale))

CUsersWindow::CUsersWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	numDisplay = (h - GUI_TITLEBAR_SIZE - (GUI_SPACING * 4)) / (USER_HEIGHT + USER_SPACING);

	ctrlScrollbar = new CScrollBar("scrollbar", ww-5-GUI_SCROLLBAR_WIDTH, 5, wh - GUI_TITLEBAR_SIZE - 10, numDisplay, 0);
	ctrlScrollbar->Resize(ctrlScrollbar->Width(), (numDisplay * (USER_HEIGHT + USER_SPACING)) - USER_SPACING);
	AddControl((CControl*)ctrlScrollbar);

	ctrlJoin = new CButton("Join", ww - 105, wh - 17, 100, 12, funcJoinPortalUser);
	ctrlJoin->SetOrigin(x, y);
	ctrlAddFriend = new CButton("Add Friend", ww - 210, wh - 17, 100, 12, funcAddPortalFriend);
	ctrlAddFriend->SetOrigin(x, y);
	ctrlRemFriend = new CButton("Remove Friend", ww - 210, wh - 17, 100, 12, funcRemPortalFriend);
	ctrlRemFriend->SetOrigin(x, y);

	strcpy(username, Portal.GetUsername());
}

CUsersWindow::~CUsersWindow(void)
{
	delete ctrlJoin;
	delete ctrlAddFriend;
	delete ctrlRemFriend;
}

void CUsersWindow::DrawUser(int drawX, int drawY, int width, int height, eth32user_t *usr, bool selected)
{
	int markerWidth = height >> 1;

	if (!usr->anon && !strcmp(eth32.server, usr->server)) {
		Syscall.R_SetColor(colorGreen);
		Draw.RawPic(drawX, drawY, markerWidth, height, eth32.cg.media.portalMarker);
		if (usr->frnd) {
			Syscall.R_SetColor(colorYellow);
			Draw.RawPic(drawX+4, drawY+4, markerWidth-8, height-8, eth32.cg.media.portalMarker);
		}
		Syscall.R_SetColor(NULL);
	} else if (usr->frnd) {
		Syscall.R_SetColor(colorYellow);
		Draw.RawPic(drawX, drawY, markerWidth, height, eth32.cg.media.portalMarker);
		Syscall.R_SetColor(NULL);
	} else {
		Syscall.R_SetColor(colorBlue);
		Draw.RawPic(drawX, drawY, markerWidth, height, eth32.cg.media.portalMarker);
		Syscall.R_SetColor(NULL);
	}

	

	drawX += markerWidth + GUI_SPACING;
	width -= markerWidth + GUI_SPACING;

	qhandle_t shader = (selected) ? eth32.guiAssets.btnselLeft : eth32.guiAssets.btnLeft;

	Draw.RawPicST(drawX, drawY, 12, 6, 0, 0, 1, 0.5, shader);
	Draw.RawPicST(drawX, drawY+6, 12, height-12, 0, .4, 1, 0.6, shader);
	Draw.RawPicST(drawX, drawY+height-6, 12, 6, 0, 0.5, 1, 1, shader);

	shader = (selected) ? eth32.guiAssets.btnselCenter : eth32.guiAssets.btnCenter;

	Draw.RawPicST(drawX + 12, drawY, width - 24, 6, 0, 0, 1, 0.5, shader);
	Draw.RawPicST(drawX + 12, drawY+6, width - 24, height-12, 0, 0.4, 1, 0.6, shader);
	Draw.RawPicST(drawX + 12, drawY+height-6, width - 24, 6, 0, 0.5, 1, 1, shader);

	shader = (selected) ? eth32.guiAssets.btnselRight : eth32.guiAssets.btnRight;

	Draw.RawPicST(drawX + width - 12, drawY, 12, 6, 0, 0, 1, 0.5, shader);
	Draw.RawPicST(drawX + width - 12, drawY+6, 12, height-12, 0, 0.4, 1, 0.6, shader);
	Draw.RawPicST(drawX + width - 12, drawY+height-6, 12, 6, 0, 0.5, 1, 1, shader);

	int textX = drawX + 5;
	int textY = drawY + 5;
	width -= 10;

	Draw.Text(textX, textY, GUI_FONTSCALE, "User:", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(textX + TEXTWIDTH("User: "), textY, GUI_FONTSCALE, usr->username, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);

	textX += width*0.35f;
	Draw.Text(textX, textY, GUI_FONTSCALE, "Server:", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(textX + TEXTWIDTH("Server: "), textY, GUI_FONTSCALE, usr->serverName, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
	
	textX += width*0.45f;
	float *compatColor = ((eth32.et->ver == usr->etVersion) || (eth32.et->ver >= ET_260 && usr->etVersion >= ET_260)) ? colorGreen : colorRed;
	Draw.Text(textX, textY, GUI_FONTSCALE, "ET Ver:", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(textX + TEXTWIDTH("ET Ver: "), textY, GUI_FONTSCALE, Tools.GetEtVersionString(usr->etVersion), compatColor, qtrue, qfalse, GUI_FONT, true);

	textX = drawX + 5;
	textY += GUI_FONTHEIGHT + 5;

	if (usr->player && *usr->player->infoValid) {
		Draw.Text(textX, textY, GUI_FONTSCALE, "Player:", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
		Draw.Text(textX + TEXTWIDTH("Player: "), textY, GUI_FONTSCALE, usr->player->name, GUI_FONTCOLOR1, qfalse, qfalse, GUI_FONT, true);
	}

	textX += width*0.35f;
	Draw.Text(textX, textY, GUI_FONTSCALE, "Map:", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(textX + TEXTWIDTH("Map: "), textY, GUI_FONTSCALE, usr->serverMapName, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);

	textX += width*0.45f;
	Draw.Text(textX, textY, GUI_FONTSCALE, "Mod:", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	Draw.Text(textX + TEXTWIDTH("Mod: "), textY, GUI_FONTSCALE, Tools.GetModVersionString(usr->modVersion), GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
}

void CUsersWindow::Display(void)
{
	ctrlScrollbar->SetNumCurrentItems(Portal.numUsers);
	CWindow::Display();

	if (!Portal.numUsers) {
		Draw.TextCenter(x + (w >> 1), y + (h >> 1), GUI_FONTSCALE, "No other users available.", GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
		return;
	}
	int drawX = x + GUI_SPACING;
	int drawY = y + GUI_TITLEBAR_SIZE + GUI_SPACING;
	int width = (ctrlScrollbar->IsActive()) ? w - (GUI_SPACING * 3) - ctrlScrollbar->Width() : w - (GUI_SPACING * 2);

	eth32user_t *usr = Portal.users;

	int startnum = (Portal.numUsers > numDisplay) ? ctrlScrollbar->GetCurrentItemNum() : 0;
	int endnum = (Portal.numUsers > numDisplay) ? startnum + numDisplay : Portal.numUsers;

	for (int i=startnum ; i<endnum ; i++) {
		bool selected = (eth32.cg.selectedPortalUser[0] && !strcmp(eth32.cg.selectedPortalUser, usr[i].username));
		DrawUser(drawX, drawY, width, USER_HEIGHT, &usr[i], selected);
		drawY += USER_HEIGHT + USER_SPACING;
	}

	char buf[64];
	sprintf(buf, "^7Total users online: ^3%i", Portal.numUsers);
	Draw.Text(x + GUI_SPACING, y2 - GUI_FONTHEIGHT - 5, GUI_FONTSCALE, buf, colorWhite, qfalse, qfalse, GUI_FONT, true);

	if (CanJoinSelected())
		ctrlJoin->Display();

	if (eth32.cg.selectedPortalUser[0] && strcmp(eth32.cg.selectedPortalUser, username)) {
		if (Portal.IsFriend(eth32.cg.selectedPortalUser))
			ctrlRemFriend->Display();
		else
			ctrlAddFriend->Display();
	}
}

int CUsersWindow::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (INBOUNDS(mx,my)) {
		if (!ctrlScrollbar->ProcessMouse(mx, my, mevent, mhook, khook))
			return 0;

		if (eth32.cg.selectedPortalUser[0] && strcmp(eth32.cg.selectedPortalUser, username)) {
			bool ret;
			if (Portal.IsFriend(eth32.cg.selectedPortalUser))
				ret = !ctrlRemFriend->ProcessMouse(mx, my, mevent, mhook, khook);
			else
				ret = !ctrlAddFriend->ProcessMouse(mx, my, mevent, mhook, khook);

			if (ret)
				return 0;
		}

		if (CanJoinSelected() && !ctrlJoin->ProcessMouse(mx, my, mevent, mhook, khook))
			return 0;

		int width = (ctrlScrollbar->IsActive()) ? w - (GUI_SPACING * 3) - ctrlScrollbar->Width() : w - (GUI_SPACING * 2);
		int height = ((USER_HEIGHT + USER_SPACING) * numDisplay) - USER_SPACING;
		int userX = x + GUI_SPACING;
		int userY = y + GUI_TITLEBAR_SIZE + GUI_SPACING;

		if (INBOUNDS2(mx,my,userX,userY,(userX+width),(userY+height)) && mevent == WM_LBUTTONDOWN) {
			int num = (my - userY) / (USER_HEIGHT + USER_SPACING);

			if (ctrlScrollbar->IsActive())
				num += ctrlScrollbar->GetCurrentItemNum();
			else if (num >= Portal.numUsers) { // prevents clicking on blank space when only a few users on screen
				eth32.cg.selectedPortalUser[0] = 0;
				return 0;
			}

			if (num < 0 || num >= MAX_PORTAL_USERS) // sanity check
				return 0;

			if (((my - userY) % (USER_HEIGHT + USER_SPACING)) <= USER_HEIGHT) {
				// set selected username here
				strcpy(eth32.cg.selectedPortalUser, Portal.users[num].username);
#ifdef ETH32_DEBUG
				Debug.Log("Portal user select: [%i] %s", num, Portal.users[num].username);
#endif
			}
			else
				eth32.cg.selectedPortalUser[0] = 0;
		}		

		return 0;
	}

	return 1;
}

int CUsersWindow::MouseWheel(int mx, int my, int wheel)
{
	if (INBOUNDS(mx,my)) {
		if (!Portal.numUsers)
			return 0;

		ctrlScrollbar->AdjCurrentItemNum(-wheel);
		return 0;
	}
	return 1;
}

bool CUsersWindow::CanJoinSelected(void)
{
	// no user selected
	if (!eth32.cg.selectedPortalUser[0])
		return false;

	// don't allow join self :f
	if (!strcmp(eth32.cg.selectedPortalUser, Portal.GetUsername()))
		return false;

	eth32user_t *usr;
	for (int i=0 ; i<Portal.numUsers ; i++)
	{
		usr = &Portal.users[i];
		if (!strcmp(eth32.cg.selectedPortalUser, usr->username)) {
			if (usr->anon || !strcmp(eth32.server, usr->server)) {
				return false; // user is alread on same server or anonymous
			}
			if (usr->etVersion == eth32.et->ver || (usr->etVersion >= ET_260 && eth32.et->ver >= ET_260)) {
				return true; // version is the same... good to go
			}
			else {
				return false; // version conflict
			}
		}
	}
	return false; // user not found
}// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"
#include "CScrollBar.h"
#include "CButtons.h"

class CUsersWindow : public CWindow
{
public:
	CUsersWindow(char *wlabel, int wx, int wy, int ww, int wh);
	~CUsersWindow(void);

	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	int MouseWheel(int mx, int my, int wheel);
	void SetProps(const char *props, float xScale, float yScale) {   }
private:
	void DrawUser(int drawX, int drawY, int width, int height, eth32user_t *usr, bool selected);
	bool CanJoinSelected(void);

	char username[64];

	CScrollBar *ctrlScrollbar;
	CButton *ctrlJoin;
	CButton *ctrlAddFriend;
	CButton *ctrlRemFriend;

	int numDisplay;
};


// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

/*********************
* CWeaponConfigWindow
*********************/

#define VIRT_WEAP_SIZE		100
#define REAL_WEAP_SIZE		(VIRT_WEAP_SIZE * eth32.cg.screenXScale)

CWeaponConfigWindow::CWeaponConfigWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	CControl *ctrl;

	int yPos = (GUI_FONTPIXELHEIGHT * 2) + VIRT_WEAP_SIZE + 20;

	autoPoints = new CDropbox("Auto Aimpoints", 5, yPos, ww-10, 23, 0, AUTOPT_MAX-1, &eth32.settings.autoPoints, autoPointText);
	AddControl((CControl*)autoPoints);
	yPos += 28;

	headTraces = new CIntSlider("Head Points", 5, yPos, ww-10, 20, 0, 64, NULL);
	AddControl((CControl*)headTraces);
	yPos += 25;

	bodyTraces = new CIntSlider("Body Points", 5, yPos, ww-10, 20, 0, 64, NULL);
	AddControl((CControl*)bodyTraces);
	yPos += 25;

	range = new CIntSlider("Range", 5, yPos, ww-10, 20, 0, 10000, NULL);
	AddControl((CControl*)range);
	yPos += 25;

	delay = new CIntSlider("Delay", 5, yPos, ww-10, 20, 0, 1000, NULL);
	AddControl((CControl*)delay);
	yPos += 25;

	autofire = new CCheckBox("Autofire", 5, yPos, ww-10, 8, NULL);
	AddControl((CControl*)autofire);
	yPos += 13;

	ctrl = new CButton("Apply to all similar type", 5, yPos, ww-10, 12, funcApplyToType);
	AddControl(ctrl);
	yPos += 17;

	ctrl = new CButton("<<", 5, yPos, (ww-20)/3 , 12, funcPrevWeapon);
	AddControl(ctrl);
	setCurrent = new CButton("Current", (ww-20)/3+10, yPos, (ww-20)/3, 12, funcViewCurrent);
	AddControl((CControl*)setCurrent);
	ctrl = new CButton(">>", 2*(ww-20)/3+15, yPos, (ww-20)/3, 12, funcNextWeapon);
	AddControl(ctrl);
	yPos += 17;

	Resize(w, GUI_TITLEBAR_SIZE + (yPos * eth32.cg.screenYScale));		
}

void CWeaponConfigWindow::Display(void)
{
	if (!eth32.cg.weaponList || !show)	// no valid weaponlist, so nothing to modify
		return;

	if (!eth32.cg.modifyWeapon) {	// find our weapon to modify if not set yet
		if (eth32.cg.snap->ps.weapon) {
			eth32.cg.modifyWeapNum = eth32.cg.snap->ps.weapon;
			eth32.cg.modifyWeapon = &eth32.cg.weaponList[eth32.cg.snap->ps.weapon];
			SetWeaponFocus();
		}
		else {
			int findweap = 0;
			// search for user defined weapon
			while (!IS_WEAPATTRIB(findweap, WA_USER_DEFINED) && findweap < eth32.cg.numWeapons)
				findweap++;
			// make sure we are still in weaponlist
			if (findweap < eth32.cg.numWeapons) {
				eth32.cg.modifyWeapNum = findweap;
				eth32.cg.modifyWeapon = &eth32.cg.weaponList[findweap];
				SetWeaponFocus();
			}
			else return;	// no user defined weapons found
		}
	}
	SetWeaponFocus();

	// Only show current button if current weapon is different than showing and current weapon is user defined
	if (eth32.cg.snap->ps.weapon && eth32.cg.modifyWeapNum != eth32.cg.snap->ps.weapon && IS_WEAPATTRIB(eth32.cg.snap->ps.weapon, WA_USER_DEFINED))
		setCurrent->Show(true);
	else setCurrent->Show(false);

	CWindow::Display();

	weapdef_t *weap = eth32.cg.modifyWeapon;

	Engine.RenderWeapon(x+(w>>1)-(REAL_WEAP_SIZE / 2), y+GUI_TITLEBAR_SIZE+(GUI_FONTHEIGHT*2)+(GUI_SPACING*3), REAL_WEAP_SIZE, eth32.cg.modifyWeapNum);

	Draw.TextCenter(x+(w>>1), y+GUI_TITLEBAR_SIZE+GUI_SPACING, GUI_FONTSCALE, weap->name, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
		
	char typetxt[32];
	switch (weap->type)
	{
	case WT_NONE:
		strcpy(typetxt, "Non Weapon");
		break;
	case WT_PISTOL:
		strcpy(typetxt, "Pistol");
		break;
	case WT_SMG:
		strcpy(typetxt, "Sub-Machine Gun");
		break;
	case WT_MG:
		strcpy(typetxt, "Machine Gun");
		break;
	case WT_EXPLOSIVE:
		strcpy(typetxt, "Explosive");
		break;
	case WT_SNIPER:
		strcpy(typetxt, "Sniper");
		break;
	case WT_RIFLE:
		strcpy(typetxt, "Rifle");
		break;
	case WT_KNIFE:
		strcpy(typetxt, "Knife");
		break;
	case WT_SHOTGUN:
		strcpy(typetxt, "Shotgun");
		break;
	case WT_HEAVY:
		strcpy(typetxt, "Heavy");
		break;
	default:
		strcpy(typetxt, "Unknown");
		break;
	}

	Draw.TextCenter(x+(w>>1), y+GUI_TITLEBAR_SIZE+GUI_SPACING+GUI_FONTHEIGHT+GUI_SPACING, GUI_FONTSCALE, typetxt, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
}

int CWeaponConfigWindow::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	int ret = CWindow::ProcessMouse(mx, my, mevent, mhook, khook);

	if (ret == 0) // a control or window handled event
		SetWeaponFocus();	// update controls, in case our mod weap has changed

	return ret;
}

void CWeaponConfigWindow::SetWeaponFocus(void)
{
	weapdef_t *weap = eth32.cg.modifyWeapon;

	if (weap) {
		// If modify weapon valid, set all our controls to point to that weapon definition
		headTraces->SetTarget(&weap->headTraces);
		bodyTraces->SetTarget(&weap->bodyTraces);
		range->SetTarget(&weap->range);
		delay->SetTarget(&weap->delay);
		autofire->SetTarget(&weap->autofire);
	}
}

// Helper Functions

void funcApplyToType(void)
{
	weapdef_t *weap = eth32.cg.modifyWeapon;
	weapdef_t *modweap = eth32.cg.weaponList;

	if (weap && modweap) { // sanity check
		for (int i=0 ; i<eth32.cg.numWeapons ; i++)
		{
			if (IS_WEAPATTRIB(i, WA_USER_DEFINED) && modweap[i].type == weap->type && weap != &modweap[i]) {
				modweap[i].headTraces = weap->headTraces;
				modweap[i].bodyTraces = weap->bodyTraces;
				modweap[i].range = weap->range;
				modweap[i].delay = weap->delay;
				modweap[i].autofire = weap->autofire;
			}
		}
	}
}

void funcPrevWeapon(void)
{
	weapdef_t *weap = eth32.cg.modifyWeapon;
	int weapnum = eth32.cg.modifyWeapNum - 1;

	if (!weap)
		return;

	if (weapnum < 0) // this shouldn't happen, but to be safe
		weapnum = eth32.cg.numWeapons;

	while (!IS_WEAPATTRIB(weapnum, WA_USER_DEFINED))
	{
		weapnum--;
		if (weapnum < 0)
			weapnum = eth32.cg.numWeapons;

		// We went through the whole list and didn't find a valid weapon def
		if (weap == &eth32.cg.weaponList[weapnum])
			return;
	}
	eth32.cg.modifyWeapNum = weapnum;
	eth32.cg.modifyWeapon = &eth32.cg.weaponList[weapnum];
}

void funcNextWeapon(void)
{
	weapdef_t *weap = eth32.cg.modifyWeapon;
	int weapnum = eth32.cg.modifyWeapNum + 1;

	if (!weap)
		return;

	if (weapnum > eth32.cg.numWeapons) // current modify weapon is last in list
		weapnum = 0;

	while (!IS_WEAPATTRIB(weapnum, WA_USER_DEFINED))
	{
		weapnum++;
		if (weapnum > eth32.cg.numWeapons)
			weapnum = 0;

		// We went through the whole list and didn't find a valid weapon def
		if (weap == &eth32.cg.weaponList[weapnum])
			return;
	}
	eth32.cg.modifyWeapNum = weapnum;
	eth32.cg.modifyWeapon = &eth32.cg.weaponList[weapnum];
}

void funcViewCurrent(void)
{
	if (eth32.cg.snap->ps.weapon && IS_WEAPATTRIB(eth32.cg.snap->ps.weapon, WA_USER_DEFINED)) {
		eth32.cg.modifyWeapNum = eth32.cg.snap->ps.weapon;
		eth32.cg.modifyWeapon = &eth32.cg.weaponList[eth32.cg.snap->ps.weapon];
	}
}

/*********************
* CHitboxWindow
*********************/

const char *hbOffsetText[] = {
	"Standing",
	"Running",
	"Crouching",
	"Crawling",
	"Prone",
};

CHitboxWindow::CHitboxWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	hitbox = &Aimbot.customHitbox;
	curPart = HB_STAND;

	AddControl(new CDropbox("Offset", 5, 5, ww-10, 23, 0, HB_MAX-1, &curPart, hbOffsetText));

	xOff = new CFloatSlider("X", 5, 33, ww-10, 20, -10, 10, &hitbox->stand_offset[0]);
	yOff = new CFloatSlider("Y", 5, 58, ww-10, 20, -10, 10, &hitbox->stand_offset[1]);
	zOff = new CFloatSlider("Z", 5, 83, ww-10, 20, -10, 10, &hitbox->stand_offset[2]);

	AddControl(xOff);
	AddControl(yOff);
	AddControl(zOff);

	AddControl(new CFloatSlider("Length (x)", 5, 108, ww-10, 20, 0, 15, &hitbox->size[0]));
	AddControl(new CFloatSlider("Width (y)", 5, 133, ww-10, 20, 0, 15, &hitbox->size[1]));
	AddControl(new CFloatSlider("Height (z)", 5, 158, ww-10, 20, 0, 15, &hitbox->size[2]));
}

void CHitboxWindow::Display(void)
{
	if (eth32.settings.hitboxType != HITBOX_CUSTOM)
		return;

	AssignHitboxPart();

	CWindow::Display();
}

void CHitboxWindow::AssignHitboxPart(void)
{
	float *curOffset;

	if (curPart == HB_STAND)
		curOffset = hitbox->stand_offset;
	else if (curPart == HB_RUNNING)
		curOffset = hitbox->stand_offset_moving;
	else if (curPart == HB_CROUCH)
		curOffset = hitbox->crouch_offset;
	else if (curPart == HB_CRAWL)
		curOffset = hitbox->crouch_offset_moving;
	else if (curPart == HB_PRONE)
		curOffset = hitbox->prone_offset;
	else // shouldn't ever get here
		curOffset = hitbox->stand_offset;

	xOff->SetTarget(&curOffset[0]);
	yOff->SetTarget(&curOffset[1]);
	zOff->SetTarget(&curOffset[2]);
}

/*********************
* CWeaponWindow
*********************/

CWeaponWindow::CWeaponWindow(char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	showTitle = false;
	chargeBarSize = 6 * eth32.cg.screenYScale;
	
	int fontSize = h - GUI_FONTHEIGHT - chargeBarSize - (4 * GUI_SPACING);
	ammoFontScale = 2.f;
	
	while (Draw.sizeTextHeight(ammoFontScale, GUI_FONT) > fontSize)
		ammoFontScale -= 0.001;
}

void CWeaponWindow::Display(void)
{
	if (!eth32.cg.snap || !eth32.cg.currentWeapon || !eth32.cg.snap->ps.weapon)
		return;

	CWindow::Display();

	int drawX = x + GUI_SPACING;
	int drawY = y + GUI_SPACING;

	weapdef_t *weap = &eth32.cg.weaponList[eth32.cg.snap->ps.weapon];

#ifdef ETH32_DEBUG
	char buf[64];
	sprintf(buf, "%s (%i)", weap->name, eth32.cg.snap->ps.weapon);
	Draw.TextCenter(x + ((w-h) >> 1), drawY, GUI_FONTSCALE, buf, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
#else
	Draw.TextCenter(x + ((w-h) >> 1), drawY, GUI_FONTSCALE, weap->name, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
#endif

	// get current charge time (ripped and modified from SDK)
	int chargeTime;
	if( eth32.cg.snap->ps.stats[ STAT_PLAYER_CLASS ] == PC_ENGINEER ) {
		chargeTime = eth32.cg.chargeTimes.engineer[eth32.cg.snap->ps.persistant[PERS_TEAM]-1];
	} else if( eth32.cg.snap->ps.stats[ STAT_PLAYER_CLASS ] == PC_MEDIC ) {
		chargeTime = eth32.cg.chargeTimes.medic[eth32.cg.snap->ps.persistant[PERS_TEAM]-1];
	} else if( eth32.cg.snap->ps.stats[ STAT_PLAYER_CLASS ] == PC_FIELDOPS ) {
		chargeTime = eth32.cg.chargeTimes.lt[eth32.cg.snap->ps.persistant[PERS_TEAM]-1];
	} else if( eth32.cg.snap->ps.stats[ STAT_PLAYER_CLASS ] == PC_COVERTOPS ) {
		chargeTime = eth32.cg.chargeTimes.covops[eth32.cg.snap->ps.persistant[PERS_TEAM]-1];
	} else {
		chargeTime = eth32.cg.chargeTimes.soldier[eth32.cg.snap->ps.persistant[PERS_TEAM]-1];
	}

	float frac;
	if (chargeTime)
		frac = (float)(eth32.cg.time - eth32.cg.snap->ps.classWeaponTime) / chargeTime;
	else
		frac = 1.f;
			
	drawY += GUI_FONTHEIGHT + GUI_SPACING;
	// draw weapon charge
	Draw.Statbar(drawX, drawY, w-h-GUI_SPACING-GUI_SPACING, chargeBarSize, frac, colorWhite);	// this will eventually show weapon charge
	// draw weapon heat
	if (eth32.cg.snap->ps.curWeapHeat)
		Draw.Statbar2(drawX, drawY, w-h-GUI_SPACING-GUI_SPACING, chargeBarSize, (float)eth32.cg.snap->ps.curWeapHeat/255.f, colorRed);

	drawY += chargeBarSize + GUI_SPACING;

	if (GetCurrentAmmo()) {
		char ammobuf[64];
		if (akimbo >= 0) 
			sprintf(ammobuf, "%i|%i/%i", akimbo, clip, ammo);
		else if (ammo >= 0)
			sprintf(ammobuf, "%i/%i", clip, ammo);
		else 
			sprintf(ammobuf, "%i", clip);

		Draw.TextCenter(x + ((w-h) >> 1), drawY, ammoFontScale, ammobuf, GUI_FONTCOLOR2, qtrue, qfalse, GUI_FONT, true);
	}

	Engine.RenderWeapon(x2-h+5, y+5, h-10);
}

bool CWeaponWindow::GetCurrentAmmo(void)
{
	ammo = clip = akimbo = -1;

	if (!orig_BG_FindClipForWeapon || !orig_BG_FindAmmoForWeapon)
		return false;

	if (!eth32.cg.snap || !eth32.cg.snap->ps.weapon)
		return false;

	if (eth32.cg.snap->ps.eFlags & EF_MG42_ACTIVE || eth32.cg.snap->ps.eFlags & EF_MOUNTEDTANK)
		return false;

	int weap = eth32.cg.snap->ps.weapon;

	if (IS_WEAPATTRIB(weap, WA_NO_AMMO))
		return false;

	clip = eth32.cg.snap->ps.ammoclip[orig_BG_FindClipForWeapon(weap)];

	if (IS_WEAPATTRIB(weap, WA_ONLY_CLIP))
		return true;

	ammo = eth32.cg.snap->ps.ammo[orig_BG_FindAmmoForWeapon(weap)];

	if (IS_WEAPATTRIB(weap, WA_AKIMBO))
		akimbo = eth32.cg.snap->ps.ammoclip[orig_BG_FindClipForWeapon(eth32.cg.weaponList[weap].otherAkimbo)];

	return true;
}







// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"
#include "CSliders.h"
#include "CCheckbox.h"
#include "CButtons.h"
#include "CAimbot.h"
#include "../types.h"	// need weapon structs

class CWeaponConfigWindow : public CWindow
{
public:
	CWeaponConfigWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
private:
	void SetWeaponFocus(void);

	CIntSlider *headTraces, *bodyTraces, *range;
	CFloatSlider *adjustx, *adjusty, *adjustz;
	CCheckBox *autofire;
	CIntSlider *delay;
	CDropbox *autoPoints;
	
	CButton *setCurrent;
};

// Helper Functions
void funcApplyToType(void);
void funcPrevWeapon(void);
void funcNextWeapon(void);
void funcViewCurrent(void);

typedef enum
{
	HB_STAND,
	HB_RUNNING,
	HB_CROUCH,
	HB_CRAWL,
	HB_PRONE,
	HB_MAX
} hitboxOffset_t;

extern const char *hbOffsetText[];

class CHitboxWindow : public CWindow
{
public:
	CHitboxWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
private:
	void AssignHitboxPart(void);
	hitbox_t *hitbox;
	CFloatSlider *xOff, *yOff, *zOff;
	int curPart;
};

class CWeaponWindow : public CWindow
{
public:
	CWeaponWindow(char *wlabel, int wx, int wy, int ww, int wh);
	void Display(void);
private:
	bool GetCurrentAmmo(void);
	int ammo, clip, akimbo;
	bool dataValid;
	float ammoFontScale;
	int chargeBarSize;
};




// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

CWindow::CWindow(const char *wlabel, int wx, int wy, int ww, int wh)
: CControl(wlabel, wx, wy, ww, wh)
{
	showTitle = true;						// will determine what origin ctrls are oriented to
	maximized = true;						// windows maximized by default
	locked = false;							// windows unlocked by default

	controlHead = controlTail = NULL;		// init our control list to NULL

	xOffset = yOffset = 0;					// because windows all use abs coords to screen origin
											// offsets are for controls in relation to parent window

	lastclick = 0;							// init last click time to 0
}

CWindow::~CWindow(void)
{
	DeleteAllControls();
}

void CWindow::Display(void)
{
	if (!show) return;
	
	vec4_t titleColor = { 0.3, 0.3, 0.6, 0.85 };
	vec4_t winColor = { 0.1, 0.1, 0.2, 0.85 };

	int yOff = 0;

	if (showTitle) {
		Draw.RawPic(x, y, GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE, eth32.guiAssets.titleLeft);
		Draw.RawPic(x+GUI_TITLEBAR_SIZE, y, w - (GUI_TITLEBAR_SIZE << 1), GUI_TITLEBAR_SIZE, eth32.guiAssets.titleCenter);
		Draw.RawPicST(x2-GUI_TITLEBAR_SIZE, y, GUI_TITLEBAR_SIZE, GUI_TITLEBAR_SIZE, 1.f, 0.f, 0.f, 1.f, eth32.guiAssets.titleLeft);

		Draw.TextCenter(x + (w >> 1), y + 3, GUI_FONTSCALE, label, GUI_TITLECOLOR, qtrue, qfalse, GUI_FONT, true);

		yOff += GUI_TITLEBAR_SIZE;
	} 
	else {
		Draw.RawPic(x, y, GUI_ESIZE, GUI_ESIZE, eth32.guiAssets.winTopLeft);
		Draw.RawPic(x + GUI_ESIZE, y, w - (GUI_ESIZE+GUI_ESIZE), GUI_ESIZE, eth32.guiAssets.winTop);
		Draw.RawPicST(x2 - GUI_ESIZE, y, GUI_ESIZE, GUI_ESIZE, 1.f, 0.f, 0.f, 1.f, eth32.guiAssets.winTopLeft);

		yOff += GUI_ESIZE;
	}
	
	if (maximized) {  // all windows without title are maximized anyway
		Draw.RawPic(x, y + yOff, GUI_ESIZE, h - GUI_ESIZE - yOff, eth32.guiAssets.winLeft);
		Draw.RawPic(x + GUI_ESIZE, y + yOff, w - (GUI_ESIZE+GUI_ESIZE), h - GUI_ESIZE - yOff, eth32.guiAssets.winCenter);
		Draw.RawPicST(x2 - GUI_ESIZE, y + yOff, GUI_ESIZE, h - GUI_ESIZE - yOff, 1.f, 0.f, 0.f, 1.f, eth32.guiAssets.winLeft);

		Draw.RawPicST(x, y2 - GUI_ESIZE, GUI_ESIZE, GUI_ESIZE, 0.f, 1.f, 1.f, 0.f, eth32.guiAssets.winTopLeft);
		Draw.RawPicST(x + GUI_ESIZE, y2 - GUI_ESIZE, w - (GUI_ESIZE+GUI_ESIZE), GUI_ESIZE, 0.f, 1.f, 1.f, 0.f, eth32.guiAssets.winTop);
		Draw.RawPicST(x2 - GUI_ESIZE, y2 - GUI_ESIZE, GUI_ESIZE, GUI_ESIZE, 1.f, 1.f, 0.f, 0.f, eth32.guiAssets.winTopLeft);

		CControl *ctrl = controlHead;
		while (ctrl) {
			ctrl->Display();
			ctrl = ctrl->next;
		}
	}	
}

int CWindow::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	// a hidden window can't process any input
	if (!show) return 1;
	
	if (INBOUNDS(mx,my)) {
		// check if mouse was in titlebar region
		if (showTitle && !locked && my <= y + GUI_TITLEBAR_SIZE) {	
			if (mevent == WM_LBUTTONDOWN) {
				uint32 click = Time();
				if ((click - lastclick) < GUI_DBLCLK_TIME) {	// minimize window if user double clicks titlebar
					maximized = !maximized;
					lastclick = 0;
				}
				else lastclick = click;
				prevx = mx;
				prevy = my;
				*mhook = this;
			}
			else *mhook = NULL;		// release mouse focus
			// event processed
			return 0;
		}
		// if maximized, check our control list
		if (maximized) {
			CControl *ctrl = controlHead;
			while (ctrl && ctrl->ProcessMouse(mx, my, mevent, mhook, khook)) {
				ctrl = ctrl->next;
			}

			if (ctrl)
				return 0;	// ctrl handled event

			if (!showTitle && mevent == WM_LBUTTONDOWN) {	// no title & no control claimed input & left button pressed
				prevx = mx;
				prevy = my;
				*mhook = this;
			}
			else *mhook = NULL;
			// mouse was within this window, event handled
			return 0;
		}
		else return 1; // window is minimized and mouse was not in titlebar region
	}
	// mouse event outside of this window
	return 1;
}

int CWindow::ProcessKeybd(unsigned char key, CControl **khook)
{
	// TODO: window function keys could be used here
	return 0;
}

int CWindow::MouseWheel(int mx, int my, int wheel)
{
	if (!show) return 1;

	if (INBOUNDS(mx,my)) {
		CControl *ctrl = controlHead;
		while (ctrl && ctrl->MouseWheel(mx, my, wheel)) {
			ctrl = ctrl->next;
		}
		return 0; // scroll event happened within our window region, handled
	}
	return 1; 
}

void CWindow::MouseMove(int mx, int my)
{
	// NOTE: this is only called when the window/control has focus in gui (mouseFocus == this)
	SetOrigin(x + mx - prevx, y + my - prevy);
	
	prevx = mx;
	prevy = my;

	CheckPosition();

	CControl *ctrl = controlHead;
	while (ctrl) {
		if (showTitle)
			ctrl->SetOrigin(x, y + GUI_TITLEBAR_SIZE);		// control coords should be relative to top/left corner not including titlebar
		else ctrl->SetOrigin(x, y);
		ctrl = ctrl->next;
	}
}

void CWindow::Reposition(int cx, int cy)
{
	CControl::Reposition(cx, cy);

	xOffset = yOffset = 0;

	CheckPosition();

	CControl *ctrl = controlHead;
	while (ctrl) {
		if (showTitle)
			ctrl->SetOrigin(x, y + GUI_TITLEBAR_SIZE);		// control coords should be relative to top/left corner not including titlebar
		else ctrl->SetOrigin(x, y);
		ctrl = ctrl->next;
	}
}

void CWindow::AddControl(CControl *ctrl)
{
	if (ctrl == NULL) return;

	ctrl->next = controlHead;
	ctrl->prev = NULL;

	if (showTitle)
		ctrl->SetOrigin(x, y + GUI_TITLEBAR_SIZE);			// control coords should be relative to top/left corner not including titlebar
	else ctrl->SetOrigin(x, y);

	if (controlHead != NULL) {
		controlHead->prev = ctrl;
		controlHead = ctrl;
	}
	else {
		controlHead = controlTail = ctrl;
	}
}

void CWindow::Refresh(void)
{
	CControl *ctrl = controlHead;

	while (ctrl) {
		ctrl->Refresh();
		ctrl = ctrl->next;
	}
}

char *CWindow::GetProps(char *s, size_t s_s)
{
	sprintf(s, "%i %i %i %i", x, y, w, h);
	return s;
}

void CWindow::SetProps(const char *props, float xScale, float yScale)
{
	int px, py, pw, ph;

	sscanf(props, "%i %i %i %i", &px, &py, &pw, &ph);
	// not using width and height for regular windows, but will use for chat and radar windows
	Reposition(px * xScale, py * yScale);	
}

CControl* CWindow::GetControlByLabel(const char *label)
{
	CControl *find = controlHead;

	char buf[64];
	while (find)
	{
		find->GetLabel(buf,sizeof(buf));
		if (!strcmp(label, buf))
			return find;

		find = find->next;
	}

	return NULL;
}

void CWindow::CheckPosition(void)
{
	// check and make sure user doesn't accidently move window off screen
	if (x2 > eth32.game.glconfig->vidWidth)
		x = eth32.game.glconfig->vidWidth - w;
	else if (x < 0)
		x = 0;
	
	x2 = x + w;

	if (y2 > eth32.game.glconfig->vidHeight)
		y = eth32.game.glconfig->vidHeight - h;
	else if (y < 0)					// dont't want titlebar to become hidden
		y = 0;
	
	y2 = y + h;
}

void CWindow::DeleteAllControls(void)
{
	CControl *del = controlHead;
	while (del) {
		controlHead = del->next;
		delete del;
		del = controlHead;
	}
	controlHead = controlTail = NULL;
}

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CControl.h"

class CWindow : public CControl
{
public:
	CWindow(const char *wlabel, int wx, int wy, int ww, int wh);
	~CWindow(void);
	virtual int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	virtual int ProcessKeybd(unsigned char key, CControl **khook);
	virtual int MouseWheel(int mx, int my, int wheel);
	virtual void MouseMove(int mx, int my);
	virtual void Display(void);
	virtual void Reposition(int cx, int cy);
	void AddControl(CControl *ctrl);
	void Refresh(void);

	virtual char* GetProps(char *s, size_t s_s);
	virtual void SetProps(const char *props, float xScale, float yScale);

	CControl* GetControlByLabel(const char *label);

	CWindow *next, *prev;
protected:
	void	CheckPosition(void);			// make sure window is not going off screen
	void	DeleteAllControls(void);		// destroy all child controls

	bool	showTitle;
	bool	maximized;
	bool	locked;
	uint32	lastclick;						// for timing doubleclicks
	int		prevx, prevy;					// used for moving the window
	CControl *controlHead, *controlTail;	
};
// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#include "../eth32.h"

/*********************
* CWindowButton
*********************/

CWindowButton::CWindowButton(const char *clabel, int cx, int cy, int cw, int ch, wincat_t cat, CWindowPicker *pwin)
: CControl(clabel, cx, cy, cw, ch)
{
	category = cat;
	windowPicker = pwin;
	winActive = false;
	winList.clear();
}

void CWindowButton::Display(void)
{
	if (!show)
		return;

	if (selected || winActive) {
		Draw.RawPic(x, y, h, h, eth32.guiAssets.btnselLeft);
		Draw.RawPic(x + h, y, w-(h+h), h, eth32.guiAssets.btnselCenter);
		Draw.RawPic(x2 - h, y, h, h, eth32.guiAssets.btnselRight);
	}
	else {
		Draw.RawPic(x, y, h, h, eth32.guiAssets.btnLeft);
		Draw.RawPic(x + h, y, w-(h+h), h, eth32.guiAssets.btnCenter);
		Draw.RawPic(x2 - h, y, h, h, eth32.guiAssets.btnRight);
	}

	Draw.TextCenter(x + (w >> 1), y + ((h - GUI_FONTHEIGHT) >> 1), GUI_FONTSCALE, label, GUI_FONTCOLOR1, qtrue, qfalse, GUI_FONT, true);
}

int CWindowButton::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	if (!show)
		return 1;

	if (INBOUNDS(mx,my)) {
		if (mevent == WM_LBUTTONDOWN) {
			selected = true;
			*mhook = this;
		}
		else if (mevent == WM_LBUTTONUP && selected) {
			winActive = !winActive;
			ShowWindows(winActive);
			
			selected = false;
			*mhook = NULL;
		}
		else {
			selected = false;
			*mhook = NULL;
		}
		return 0;
	}
	return 1;
}

void CWindowButton::MouseMove(int mx, int my)
{
	selected = INBOUNDS(mx,my);
}

void CWindowButton::ShowWindows(bool show)
{
	winActive = show;
	
	if (show)
		windowPicker->WindowActiveCallback(category);
	
	list<CWindow*>::iterator win_iter = winList.begin();
	
	while (win_iter != winList.end()) {
		(*win_iter)->Show(show);
		win_iter++;
	}
}

void CWindowButton::AddWindow(CWindow *win)
{
	winList.push_front(win);
}

/*********************
* CWindowPicker
*********************/

CWindowPicker::CWindowPicker(const char *wlabel, int wx, int wy, int ww, int wh)
: CWindow(wlabel, wx, wy, ww, wh)
{
	showTitle = false;
	locked = true;

	allowMultiWindows = false;
	activeWinCount = buttonCount = 0;
	lastActive = CAT_AIMBOT;

	Reposition(GUI_SPACING, GUI_SPACING);
	Resize(eth32.game.glconfig->vidWidth - (GUI_SPACING*2), h);

	buttons[CAT_AIMBOT] = new CWindowButton("Aimbot", 5, 5, 100, 13, CAT_AIMBOT, this);
	buttons[CAT_VISUAL] = new CWindowButton("Visuals", 5, 5, 100, 13, CAT_VISUAL, this);
	buttons[CAT_NETWORK] = new CWindowButton("Network", 5, 5, 100, 13, CAT_NETWORK, this);
	buttons[CAT_MISC] = new CWindowButton("Misc", 5, 5, 100, 13, CAT_MISC, this);

	ReorganizeButtons();

	ctrlMulti = new CCheckBox("Allow Multiple Windows", ww-155, wh-13, 150, 8, &allowMultiWindows);
	ctrlMulti->SetOrigin(x, y);	
}

CWindowPicker::~CWindowPicker(void)
{
	for (int i=0 ; i<CAT_MAX ; i++)
	{
		if (buttons[i])
			delete buttons[i];
	}

	if (ctrlMulti)
		delete ctrlMulti;
}

void CWindowPicker::Display(void)
{
	CWindow::Display();

	for (int i=0 ; i<CAT_MAX ; i++)
	{
		if (buttons[i]) {
			if (!allowMultiWindows && i != lastActive) 
				buttons[i]->ShowWindows(false);
			buttons[i]->Display();
		}
	}
			
	ctrlMulti->Display();
}

int CWindowPicker::ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook)
{
	// a hidden window can't process any input
	if (!show) return 1;
	
	if (INBOUNDS(mx,my)) {
		for (int i=0 ; i<CAT_MAX ; i++) {
			if (buttons[i] && !buttons[i]->ProcessMouse(mx, my, mevent, mhook, khook))
				return 0;
		}
		ctrlMulti->ProcessMouse(mx, my, mevent, mhook, khook);
		return 0;
	}
	// mouse event outside of this window
	return 1;
}

void CWindowPicker::AddWindow(const char *winTitle, wincat_t cat)
{
	CWindow *win = Gui.GetWinByTitle(winTitle);

	if (!win || cat == CAT_MAX)
		return;

	buttons[cat]->AddWindow(win);
}

void CWindowPicker::ClearAll(void)
{
	for (int i=0 ; i<CAT_MAX ; i++)
	{
		buttons[i]->ShowWindows(false);
	}
}

// callback is used to close other open windows when user only wants 1 open at a time
void CWindowPicker::WindowActiveCallback(wincat_t cat)
{
	lastActive = cat;

	if (allowMultiWindows)
		return;

	for (int i=0 ; i<CAT_MAX ; i++)
	{
		if (i != cat && buttons[i])
			buttons[i]->ShowWindows(false);
	}
}	

void CWindowPicker::ReorganizeButtons(void)
{
	int xPos = GUI_SPACING;
	int yPos = GUI_SPACING;
	int btnWidth = (w - ((CAT_MAX + 1) * GUI_SPACING)) / CAT_MAX;

	for (int i=0 ; i<CAT_MAX ; i++)
	{
		buttons[i]->Reposition(xPos, yPos);
		buttons[i]->Resize(btnWidth, buttons[i]->Height());
		buttons[i]->SetOrigin(x, y);

		xPos += (btnWidth + GUI_SPACING);
	}
}
	







// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "CWindow.h"
#include "CCheckbox.h"

typedef enum {
	CAT_AIMBOT,
	CAT_VISUAL,
	CAT_NETWORK,
	CAT_MISC,
	CAT_MAX,
} wincat_t;

class CWindowPicker;

class CWindowButton : public CControl
{
public:
	CWindowButton(const char *clabel, int cx, int cy, int cw, int ch, wincat_t cat, CWindowPicker *pwin);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	void MouseMove(int mx, int my);
	bool WindowActive(void) { return winActive; }
	void ShowWindows(bool show);
	void AddWindow(CWindow *win);
private:
	wincat_t category;
	list<CWindow*> winList;
	CWindowPicker *windowPicker;
	bool winActive;
};

class CWindowPicker : public CWindow
{
public:
	CWindowPicker(const char *wlabel, int wx, int wy, int ww, int wh);
	~CWindowPicker(void);
	void Display(void);
	int ProcessMouse(int mx, int my, uint32 mevent, CControl **mhook, CControl **khook);
	void AddWindow(const char *winTitle, wincat_t cat);
	void ClearAll(void);	
	void WindowActiveCallback(wincat_t cat);
	void SetProps(const char *props, float xScale, float yScale) {   }
private:
	CWindowButton *buttons[CAT_MAX];

	void ReorganizeButtons(void);
	CCheckBox *ctrlMulti;
	wincat_t lastActive;
	bool allowMultiWindows;
	int buttonCount;
	int activeWinCount;
};

// ETH32 - an Enemy Territory cheat for windows
// Copyright (c) 2007 eth32 team
// www.cheatersutopia.com & www.nixcoders.org

#pragma once

#include "gui/CBallisticWindow.h"
#include "gui/CButtons.h"
#include "gui/CCameraWindow.h"
#include "gui/CChatWindow.h"
#include "gui/CCheckbox.h"
#include "gui/CClientWindow.h"
#include "gui/CColorPicker.h"
#include "gui/CControl.h"
#include "gui/CEspWindow.h"
#include "gui/CEspConfigWindow.h"
#include "gui/CIrcWindow.h"
#include "gui/CPlayerWindow.h"
#include "gui/CRadarWindow.h"
#include "gui/CRespawnWindow.h"
#include "gui/CScrollBar.h"
#include "gui/CSliders.h"
#include "gui/CSpecWindow.h"
#include "gui/CStatusWindow.h"
#include "gui/CStatsWindow.h"
#include "gui/CTextControls.h"
#include "gui/CUsersWindow.h"
#include "gui/CWeaponWindow.h"
#include "gui/CWindow.h"
#include "gui/CWindowPicker.h"

#define INBOUNDS(xx,yy)					((xx >= x) && (xx <= x2) && (yy >= y) && (yy <= y2))
#define INBOUNDS2(xx,yy,x1,y1,x2,y2)	((xx >= x1) && (xx <= x2) && (yy >= y1) && (yy <= y2))
#define INBOUNDS3(xx,yy,cx,cy,ww,hh)	((xx >= (cx-ww)) && (xx <= (cx+ww)) && (yy >= (cy-hh)) && (yy <= (cy+hh)))

// these should eventually be part of gui itself
#define GUI_FONT				&eth32.cg.media.fontArial
#define GUI_FONTSCALE			eth32.guiAssets.fontScale
#define GUI_SMALLFONTSCALE		GUI_FONTSCALE * 0.75f
#define GUI_FONTPIXELHEIGHT		8 // in 640x480 resolution, will scale to other resolutions
#define GUI_FONTHEIGHT			eth32.guiAssets.fontHeight//11//(int)(GUI_FONTPIXELHEIGHT * eth32.cg.screenYScale)
#define GUI_TITLEBAR_SIZE		(GUI_FONTHEIGHT + 6)
#define GUI_ESIZE				GUI_TITLEBAR_SIZE
#define GUI_TEXTSPACING			2
#define GUI_SPACING				(5 * eth32.cg.screenXScale)
#define GUI_TITLECOLOR			eth32.guiAssets.titleColor
#define GUI_FONTCOLOR1			eth32.guiAssets.textColor1
#define GUI_FONTCOLOR2			eth32.guiAssets.textColor2

#define TEXTWIDTH(str)			Draw.sizeTextWidth(GUI_FONTSCALE, str, GUI_FONT)

#define GUI_SCROLLBAR_WIDTH		10
#define GUI_SCROLL_BTN_MIN		10

#define GUI_DBLCLK_TIME			500		// time between clicks in msec

#define GUI_MAXWINCTRLS			16
#define GUI_CURFLASHTIME		400		// time in ms of text cursor on / off flashing

#define GUI_MAXCONSOLECMDS		16		// maximum number of console cmds we can buffer
#define GUI_MAXCONSOLEMSGS		32
#define GUI_CONSOLEMSGSIZE		1024	// maximum length of any given buffered cmd

#define GUI_MAXSTYLES			16
#define GUI_MAXVALUESIZE		1024

#define GUI_STYLES_FILE			"styles.ini"

// probably define these in IRC header once established
#define IRC_BUFFER_SIZE			512
#define IRC_MAX_MSG_LEN			256

typedef enum {
	GUI_MAINVIEW,
	GUI_MENUVIEW,
	GUI_IRCVIEW,
	GUI_CLIENTVIEW,
	GUI_USERVIEW,
	GUI_MAXVIEWS
} viewtype_t;

typedef struct view_s {
	CWindow *head;
	CWindow *tail;

	int	vkeyToggle;			// key to open/close a view
	int vkeyMouseEnable;	// key that must be pressed to allow keybd input
	int vkeyClose;			// key that will close view and restore default (GUI_MAINVIEW)

	void (*openfunc)(void);	// function to call when this view is opened
} view_t;

typedef enum {
	CTRL_CHECKBOX,
	CTRL_INTDISPLAY,
	CTRL_FLOATDISPLAY,
	CTRL_INTSLIDER,
	CTRL_FLOATSLIDER,
	CTRL_DROPBOX,
	CTRL_COLORPICKER,
	CTRL_MAX
} ctrltype_t;

typedef enum {
	WIN_BALLISTIC,
	WIN_CHAT,
	WIN_IRC,
	WIN_USERS,
	WIN_CLIENTS,
	WIN_RADAR,
	WIN_HITBOX,
	WIN_STANDARD,
	WIN_STATUS,
	WIN_STATS,
	WIN_WEAPCONFIG,
	WIN_WEAPON,
	WIN_XHAIRINFO,
	WIN_WINAMP,
	WIN_CAMERA,
	WIN_CAMCONFIG,
	WIN_ESPCONFIG,
	WIN_RESPAWN,
 	WIN_SPECTATOR,
	WIN_MAX
} wintype_t;

typedef struct {
	ctrltype_t type;					// used to determine how to cast arg0-arg4
	char *label;						// common to all controls
	int x, y, w, h;						// common to all controls
	int arg0, arg1, arg2, arg3, arg4;	// used for different types of controls, will be casted on creation
} ctrldef_t;

typedef struct {
	char *title;		// window title
	wintype_t type;		// window type to create
	viewtype_t view;	// which view we want to add it to
	int x, y, w, h;		// position and size
	int numCtrls;		// num controls
	ctrldef_t ctrls[GUI_MAXWINCTRLS];	// array of ctrls to be added
} windef_t;

typedef enum {
	ASSET_VEC3,
	ASSET_VEC4,
	ASSET_SHADERNOMIP,
	ASSET_SHADER,
	MAX_ASSETS,
} assettype_t;

typedef struct {
	char *key;
	assettype_t type;
	void *target;
} assetdef_t;
